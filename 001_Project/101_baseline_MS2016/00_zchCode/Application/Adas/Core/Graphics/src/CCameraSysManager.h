//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Adas
//  @ File Name : CCameraSysManager.h
//  @ Date : 2/16/2015
//  @ Author : 
//
//


#if !defined(_CCAMERASYSMANAGER_H)
#define _CCAMERASYSMANAGER_H

#include "screen/screen.h"
#include "foundation.h"
#include "CBaseGraphicsImpl.h"
#include "videoCapture/CaptureDriverConfig.h"
#include "graphics/render.h"

enum ECapDriverType
{
	eQNX_J5,
	eQNX_IMX6_7182,
	eCapDriverNum
};


enum ECapCamSigEvent
{
	eSignal1Valid,
	eSignal2Valid,
	eSignal1Invalid,
	eSignal2Invalid,
	eSignal1InitValid,
	eSignal2InitValid,
	eSignal1InitInvalid,
	eSignal2InitInvalid,
	eCapCamSigEventNum,
};
typedef void (*CAPTURECALLBACK)(ECapCamSigEvent eSigEvent);
typedef void (*LAYERCALLBACK)(void);
struct tagGraphicsConfig
{
	string 	strWinName;
	Int32 	iPipeline;
	Int32 	iWinPos[2];
	UInt32 	uiWinSize[2];
	UInt32 	uiBufNum;
    LAYERCALLBACK	pLayerReadyCallback;
};

struct tagCaptureConfig
{
	string 			strWinName;
	Int32 			iPipeline;
	Int32 			iWinPos[2];
	UInt32 			uiWinSize[2];
	UInt32 			uiBufNum;
	UInt32 			uiBufSize[2];
	UInt32 			uiPixelBytes;
	UInt32			uiFormat;
	UInt32			uiCheckSignal;
    UInt32			uiSkipFrames;
	CAPTURECALLBACK	pSignalCallback;
    LAYERCALLBACK	pLayerReadyCallback;
    LAYERCALLBACK	pSetLayerReqCallback;
	ECapDriverType 	eDriverType;
    UInt32          uiSkipFramesForSigDelay;
};

class CCaptureThread;
class CGraphicsThread;

class CCameraSysManager
{
public://enum struct
	enum EType
	{
		eType_SV,
		eType_Simple,
	};

public://method

	static CCameraSysManager* getInstance();
	static void deleteInstance();

	CCameraSysManager();
	~CCameraSysManager();

	BOOLEAN	initialize(EType eType);
	void	unInitialize();
	void 	addCapture(const tagCaptureConfig& captureCfg, void* pDriverConfig, CAPTURECALLBACK callback);
	void 	initGraphics(const tagGraphicsConfig& graphicsCfg, CBaseGraphicsImpl* pGraphicsImpl );

	void	setPosAndSize(const CRectangle& rc);
	void	setPosAndSize(Int32 iX, Int32 iY, UInt32 uiW, UInt32 uiH);
//if init camera connection state is not updated and camera is not enabled
//set camerasource to trigger a callback on camera signal
//for app side, on receiving the callback check if camera ctrl state is enabled then send out state accordingly
//use another thread to moitor caemera state and run camera at manage module level
//a seperate moudle to change camera state, same level user as adas moudule, not affect the state inside it
	void 	setCameraSourceIndex(UInt32 uidx);
	void  	setCameraState(bool bEnable);

	void	pause();
	void	resume();
    void    setSkipFrame(int i);//debug interface
	void	PauseSafeLock()  ;
	void	PauseSafeUnLock();
	void	PauseSafeWait()  ;
    void    DisablePostData();
	BOOLEAN	isActive() const	{ return m_bActive;	}

	void	pushGraphicsMessage(const tagBaseMessage& rMsg, UInt32 uiLen);

	screen_context_t	getScreenCtx()					{ return m_screen_ctx;	}
	screen_display_t	getScreenDisplay(UInt32 i=0)	{ return m_screen_disp[i];}
    void                asyncSetReportCameraLayerReady();
    void                asyncSetReportGraphicLayerReady();
protected://method
	//BOOLEAN

private://data
	static CCameraSysManager*	s_pInstance;

	EType	m_eType;
	BOOLEAN	m_bActive;
    //keep correct order for pause and resume in fast state swtich case
    CEvent  m_cPauseSafeLock;
    
	Array<CCaptureThread*> 	m_aryCaptureThread;
	CGraphicsThread* 		m_pGraphicsThread;
//#ifdef PLATFORM_QNX
	screen_context_t     	m_screen_ctx;
	screen_display_t    *	m_screen_disp;

};

#endif  //_CCAMERASYSMANAGER_H
