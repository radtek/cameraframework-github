//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Adas
//  @ File Name : CCameraSysManager.cpp
//  @ Date : 2/16/2015
//  @ Author : 
//
//


#include "CCameraSysManager.h"
#include "simple/CSimpleCaptureThread.h"
#include "simple/CSimpleGraphicsThread.h"
#include "simple/CSimpleCaptureMessageHandler.h"
#include "simple/CSimpleGraphicsMessageHandler.h"

CCameraSysManager* CCameraSysManager::s_pInstance = NULL;

CCameraSysManager* CCameraSysManager::getInstance()
{
	if( s_pInstance == NULL )
	{
		s_pInstance = new CCameraSysManager();
	}

	return s_pInstance;
}

void CCameraSysManager::deleteInstance()
{
	if( s_pInstance )
	{
		delete s_pInstance;
		s_pInstance = NULL;
	}
}

CCameraSysManager::CCameraSysManager()
: m_eType(eType_SV)
, m_bActive(TRUE)
, m_cPauseSafeLock(false)
, m_pGraphicsThread(NULL)
, m_screen_ctx(NULL)
, m_screen_disp(NULL)
{

}

CCameraSysManager::~CCameraSysManager()
{

}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, initialize);
BOOLEAN CCameraSysManager::initialize(EType eType)
{
	TRC_SCOPE(ADAS, CCameraSysManager, initialize);
	m_eType = eType;
	//m_uiDisplayNum = uiDisplayNum;

	Int32 rc = screen_create_context(&(m_screen_ctx), 0);
	if (rc) {
		DBG_ERROR(("screen_context_create:%s\n",strerror(errno)));
		return FALSE;
	}

	//if( m_uiDisplayNum > 0 )
	{
		Int32 iDisplayNum;
		rc = screen_get_context_property_iv(m_screen_ctx, SCREEN_PROPERTY_DISPLAY_COUNT, (Int32*)&iDisplayNum);
		if (rc) {
			DBG_ERROR(("screen_get_context_property_iv(SCREEN_PROPERTY_DISPLAY_COUNT):%s\n",strerror(errno)));
			return FALSE;
		}

		m_screen_disp = (screen_display_t*)malloc(iDisplayNum * sizeof(screen_display_t) );
		if (m_screen_disp == NULL) {
			DBG_ERROR(("could not allocate memory for display list:%s\n",strerror(errno)));
			return FALSE;
		}

		rc = screen_get_context_property_pv(m_screen_ctx, SCREEN_PROPERTY_DISPLAYS, (void **)(m_screen_disp));
		if (rc) {
			DBG_ERROR(("screen_get_context_property_ptr(SCREEN_PROPERTY_DISPLAYS):%s\n",strerror(errno)));
			return FALSE;
		}
	}

	return TRUE;
}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, unInitialize);
void CCameraSysManager::unInitialize()
{
	TRC_SCOPE(ADAS, CCameraSysManager, unInitialize);
	for(UInt32 i = 0 ; i < m_aryCaptureThread.size(); ++i )
	{
		m_aryCaptureThread[i]->resume();
		m_aryCaptureThread[i]->quit();
		m_aryCaptureThread[i]->join();
		delete m_aryCaptureThread[i];
	}
	m_aryCaptureThread.clear();

	if( m_pGraphicsThread )
	{
		m_pGraphicsThread->resume();
		m_pGraphicsThread->quit();
		m_pGraphicsThread->join();
		delete m_pGraphicsThread;
		m_pGraphicsThread = NULL;
	}

	if(m_screen_disp)
	{
		free(m_screen_disp);
		m_screen_disp = NULL;
	}

	if(m_screen_ctx)
	{
		screen_destroy_context(m_screen_ctx);
		m_screen_ctx = NULL;
	}

	DBG_MSG(("******************CCameraSysManager::unInitialize() end*****************\n"));
}

void CCameraSysManager::addCapture(const tagCaptureConfig& captureCfg, void* pDriverConfig, CAPTURECALLBACK callback)
{
	CCaptureThread* p = NULL;
	CMessageHandler* pMsgHandler = NULL;
	switch(m_eType)
	{
	case eType_Simple:
		p = new CSimpleCaptureThread("capture thread");
		pMsgHandler = new CSimpleCaptureMessageHandler();
		break;
	case eType_SV:
		break;
	}

	if( p )
	{
		m_aryCaptureThread.push_back(p);
		p->setConfig(captureCfg, pDriverConfig, callback);
		p->start(new CMessageQueue("captureMsgQueue", 50, pMsgHandler));
	}
}

void CCameraSysManager::initGraphics(const tagGraphicsConfig& graphicsCfg, CBaseGraphicsImpl* pGraphicsImpl)
{
	CGraphicsThread* p = NULL;
	CMessageHandler* pMsgHandler = NULL;
	switch(m_eType)
	{
	case eType_Simple:
	//	p = new CSimpleGraphicsThread("graphics Thread",pGraphicsImpl);
		p = CSimpleGraphicsThread::getInstance(pGraphicsImpl);
		pMsgHandler = new CSimpleGraphicsMessageHandler();
		break;
	case eType_SV:
		break;
	}

	if( p )
	{
		m_pGraphicsThread = p;
		p->setConfig(graphicsCfg);
		p->start(new CMessageQueue("graphicsMsgQueue", 50, pMsgHandler));
	}
}

void CCameraSysManager::setPosAndSize(const CRectangle& rc)
{
	setPosAndSize(rc.getX(),rc.getY(),rc.getWidth(),rc.getHeight());
}

void CCameraSysManager::setPosAndSize(Int32 iX, Int32 iY, UInt32 uiW, UInt32 uiH)
{
	if( m_eType == eType_Simple && !m_aryCaptureThread.empty() )
	{
		CSimpleCaptureThread* p = (CSimpleCaptureThread*)m_aryCaptureThread[0];
		if( p )
		{
			p->setScreenPosAndSize(iX,iY,uiW,uiH);
		}

	}
}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, setCameraSourceIndex);
void CCameraSysManager::setCameraSourceIndex(UInt32 uidx)
{
	if( m_eType == eType_Simple && !m_aryCaptureThread.empty() )
	{
		TRC_SCOPE(ADAS, CCameraSysManager, setCameraSourceIndex);
		DBG_MSG(("CCameraSysManager::setCameraSourceIndex %u\n", uidx));
		CSimpleCaptureThread* p = (CSimpleCaptureThread*)m_aryCaptureThread[0];
		if( p )
		{
			p->setCameraSourceIndex(uidx);
		}
	}
}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, setCameraState);
void CCameraSysManager::setCameraState(BOOLEAN bEnable)
{
	if( m_eType == eType_Simple && !m_aryCaptureThread.empty() )
	{
		TRC_SCOPE(ADAS, CCameraSysManager, setCameraState);
		DBG_MSG(("CCameraSysManager::setCameraState %d\n", bEnable));
		CSimpleCaptureThread* p = (CSimpleCaptureThread*)m_aryCaptureThread[0];
		if( p )
		{
			p->setCameraState(bEnable);
		}
	}
}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, pause);
void CCameraSysManager::pause()
{
	if( m_bActive )
	{
        PauseSafeLock();
		TRC_SCOPE(ADAS, CCameraSysManager, pause);
		DBG_MSG(("CCameraSysManager::pause()\n"));
		if( m_pGraphicsThread )
		{
			m_pGraphicsThread->pause();
		}
        CSimpleCaptureThread* p = NULL;
		for(UInt32 i = 0 ; i < m_aryCaptureThread.size(); ++i )
		{
            p = (CSimpleCaptureThread*)m_aryCaptureThread[i];
			p->asyncPause(makeFunctor0(this,&CCameraSysManager::PauseSafeUnLock));
		}
		m_bActive = FALSE;
	}
}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, DisablePostData);
void CCameraSysManager::DisablePostData()
{
		TRC_SCOPE(ADAS, CCameraSysManager, DisablePostData);
		DBG_MSG(("CCameraSysManager::DisablePostData()\n"));
        CSimpleCaptureThread* p ;
		for(UInt32 i = 0 ; i < m_aryCaptureThread.size(); ++i )
		{
            p= (CSimpleCaptureThread*)m_aryCaptureThread[i];
            p->DisablePostData();
		}
}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, setSkipFrame);
void CCameraSysManager::setSkipFrame(int i)
{
    TRC_SCOPE(ADAS, CCameraSysManager, setSkipFrame);
	CSimpleCaptureThread* p = (CSimpleCaptureThread*)m_aryCaptureThread[0];
	if( p )
	{
        DBG_MSG(("--->setSkipFrame %d\n",i));
		p->setSkipFrames(i);
	}
}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, resume);
void CCameraSysManager::resume()
{
	if ( !m_bActive )
	{
        PauseSafeWait();
		TRC_SCOPE(ADAS, CCameraSysManager, resume);
		DBG_MSG(("CCameraSysManager::resume()\n"));
        DisablePostData();
		for(UInt32 i = 0 ; i < m_aryCaptureThread.size(); ++i )
		{
			m_aryCaptureThread[i]->resume();
		}

		if( m_pGraphicsThread )
		{
			m_pGraphicsThread->resume();
		}

		m_bActive = TRUE;
	}
}
TRC_SCOPE_DEF(ADAS, CCameraSysManager, PauseSafeLock);
void CCameraSysManager::PauseSafeLock()
{
	TRC_SCOPE(ADAS, CCameraSysManager, PauseSafeLock);
	DBG_MSG(("--->PauseSafeLock\n"));
	m_cPauseSafeLock.reset();
};
TRC_SCOPE_DEF(ADAS, CCameraSysManager, PauseSafeUnLock);
void CCameraSysManager::PauseSafeUnLock()
{
	TRC_SCOPE(ADAS, CCameraSysManager, PauseSafeUnLock);
	DBG_MSG(("--->PauseSafeUnLock\n"));
	m_cPauseSafeLock.set();
};
TRC_SCOPE_DEF(ADAS, CCameraSysManager, PauseSafeWait);
void CCameraSysManager::PauseSafeWait()
{
	TRC_SCOPE(ADAS, CCameraSysManager, PauseSafeWait);
	DBG_MSG(("--->PauseSafeWait\n"));
	m_cPauseSafeLock.wait();
};

void CCameraSysManager::pushGraphicsMessage(const tagBaseMessage& rMsg, UInt32 uiLen)
{
	if( m_pGraphicsThread )
	{
		m_pGraphicsThread->pushMessage(rMsg, uiLen);
	}
}


void CCameraSysManager::asyncSetReportGraphicLayerReady()
{
    if( m_pGraphicsThread )
    {
    	m_pGraphicsThread->setNeedReportLayerReady();
    }
}

void CCameraSysManager::asyncSetReportCameraLayerReady()
{
	if( m_eType == eType_Simple && !m_aryCaptureThread.empty() )
	{
		CSimpleCaptureThread* p = (CSimpleCaptureThread*)m_aryCaptureThread[0];
		if( p )
		{
			p->setReportLayerReady();
		}

	}
}

