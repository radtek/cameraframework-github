/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.201702211714.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.3.0
* generated on: Tue Aug 01 13:37:50 CST 2017
*/
#include <v0/com/harman/adas/AdasService.hpp>
#include <v0/com/harman/adas/AdasServiceDBusStubAdapter.hpp>

namespace v0 {
namespace com {
namespace harman {
namespace adas {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createAdasServiceDBusStubAdapter(
                   const CommonAPI::DBus::DBusAddress &_address,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
                   const std::shared_ptr<CommonAPI::StubBase> &_stub) {
    return std::make_shared<AdasServiceDBusStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerAdasServiceDBusStubAdapter) {
    CommonAPI::DBus::Factory::get()->registerStubAdapterCreateMethod(
    	AdasService::getInterface(), &createAdasServiceDBusStubAdapter);
}

AdasServiceDBusStubAdapterInternal::~AdasServiceDBusStubAdapterInternal() {
    deactivateManagedInstances();
    AdasServiceDBusStubAdapterHelper::deinit();
}

void AdasServiceDBusStubAdapterInternal::deactivateManagedInstances() {

}

const char* AdasServiceDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getCurrentStateAttribute\">\n"
            "<arg name=\"value\" type=\"a(si)\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCurrentStateAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"a(si)\" />\n"
        "</signal>\n"
        "<signal name=\"aAdasModuleState\">\n"
            "<arg name=\"modulesState\" type=\"a(si)\" />\n"
        "</signal>\n"
        "<method name=\"getModuleState\">\n"
            "<arg name=\"_moduleName\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_moduleState\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v0::com::harman::adas::AdasServiceStub,
        CommonAPI::Version
        > AdasServiceDBusStubAdapterInternal::getAdasServiceInterfaceVersionStubDispatcher(&AdasServiceStub::getInterfaceVersion, "uu");

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v0::com::harman::adas::AdasServiceStub,
        ::v1::com::harman::adas::AdasType::aModuleState,
        ::v1::com::harman::adas::AdasType_::aModuleStateDeployment_t
        > AdasServiceDBusStubAdapterInternal::getCurrentStateAttributeStubDispatcher(
            &::v0::com::harman::adas::AdasServiceStub::getCurrentStateAttribute
            , "a(si)"
            );



CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v0::com::harman::adas::AdasServiceStub,
    std::tuple<std::string>,
    std::tuple<::v1::com::harman::adas::AdasType::eModuleStates>,
    std::tuple<CommonAPI::DBus::StringDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > AdasServiceDBusStubAdapterInternal::getModuleStateStubDispatcher(
    &AdasServiceStub::getModuleState, "i",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));


void AdasServiceDBusStubAdapterInternal::fireCurrentStateAttributeChanged(const ::v1::com::harman::adas::AdasType::aModuleState& value) {
    CommonAPI::Deployable<::v1::com::harman::adas::AdasType::aModuleState, ::v1::com::harman::adas::AdasType_::aModuleStateDeployment_t> deployedValue(value, static_cast<::v1::com::harman::adas::AdasType_::aModuleStateDeployment_t*>(nullptr));
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    CommonAPI::Deployable<
        ::v1::com::harman::adas::AdasType::aModuleState,
        ::v1::com::harman::adas::AdasType_::aModuleStateDeployment_t
    >
    >>
        ::sendSignal(
            *this,
            "onCurrentStateAttributeChanged",
            "a(si)",
            deployedValue
    
    );
}

void AdasServiceDBusStubAdapterInternal::fireAAdasModuleStateEvent(const ::v1::com::harman::adas::AdasType::aModuleState& modulesState) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    CommonAPI::Deployable<::v1::com::harman::adas::AdasType::aModuleState, ::v1::com::harman::adas::AdasType_::aModuleStateDeployment_t>
    >>::sendSignal(
            *this,
            "aAdasModuleState",
            "a(si)",
    CommonAPI::Deployable<::v1::com::harman::adas::AdasType::aModuleState, ::v1::com::harman::adas::AdasType_::aModuleStateDeployment_t>(modulesState, static_cast<::v1::com::harman::adas::AdasType_::aModuleStateDeployment_t*>(nullptr))
    );
}


const AdasServiceDBusStubAdapterHelper::StubDispatcherTable& AdasServiceDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::DBus::StubAttributeTable& AdasServiceDBusStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

AdasServiceDBusStubAdapterInternal::AdasServiceDBusStubAdapterInternal(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
        const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::DBus::DBusStubAdapter(_address, _connection,false),
      AdasServiceDBusStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<AdasServiceStub>(_stub), false),
      stubDispatcherTable_({
            { { "getCurrentStateAttribute", "" }, &com::harman::adas::AdasServiceDBusStubAdapterInternal::getCurrentStateAttributeStubDispatcher }
            ,
            { { "getModuleState", "s" }, &com::harman::adas::AdasServiceDBusStubAdapterInternal::getModuleStateStubDispatcher }
            }),
        stubAttributeTable_() {

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &com::harman::adas::AdasServiceDBusStubAdapterInternal::getAdasServiceInterfaceVersionStubDispatcher });
}

bool AdasServiceDBusStubAdapterInternal::hasFreedesktopProperties() {
    return false;
}

} // namespace adas
} // namespace harman
} // namespace com
} // namespace v0
