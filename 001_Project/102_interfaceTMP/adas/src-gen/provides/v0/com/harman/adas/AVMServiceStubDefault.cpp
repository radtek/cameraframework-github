/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.201702211714.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.3.0
* generated on: Tue Aug 01 13:37:50 CST 2017
*/
#include <v0/com/harman/adas/AVMServiceStubDefault.hpp>
#include <assert.h>

namespace v0 {
namespace com {
namespace harman {
namespace adas {

AVMServiceStubDefault::AVMServiceStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(AVMService::getInterfaceVersion()) {
}

const CommonAPI::Version& AVMServiceStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

AVMServiceStubRemoteEvent* AVMServiceStubDefault::initStubAdapter(const std::shared_ptr<AVMServiceStubAdapter> &_adapter) {
    CommonAPI::Stub<AVMServiceStubAdapter, AVMServiceStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

const ::v1::com::harman::adas::AVMBaseType::stAVMCamState& AVMServiceStubDefault::getAVMCamStatusAttribute() {
    return aVMCamStatusAttributeValue_;
}

const ::v1::com::harman::adas::AVMBaseType::stAVMCamState& AVMServiceStubDefault::getAVMCamStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getAVMCamStatusAttribute();
}

void AVMServiceStubDefault::setAVMCamStatusAttribute(::v1::com::harman::adas::AVMBaseType::stAVMCamState _value) {
    const bool valueChanged = trySetAVMCamStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<AVMServiceStubAdapter, AVMServiceStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireAVMCamStatusAttributeChanged(aVMCamStatusAttributeValue_);
    }
}

bool AVMServiceStubDefault::trySetAVMCamStatusAttribute(::v1::com::harman::adas::AVMBaseType::stAVMCamState _value) {
    if (!validateAVMCamStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (aVMCamStatusAttributeValue_ != _value);
    aVMCamStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool AVMServiceStubDefault::validateAVMCamStatusAttributeRequestedValue(const ::v1::com::harman::adas::AVMBaseType::stAVMCamState &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::adas::CTABaseType::stCTAStatus& AVMServiceStubDefault::getCTAStatusAttribute() {
    return cTAStatusAttributeValue_;
}

const ::v1::com::harman::adas::CTABaseType::stCTAStatus& AVMServiceStubDefault::getCTAStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getCTAStatusAttribute();
}

void AVMServiceStubDefault::setCTAStatusAttribute(::v1::com::harman::adas::CTABaseType::stCTAStatus _value) {
    const bool valueChanged = trySetCTAStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<AVMServiceStubAdapter, AVMServiceStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireCTAStatusAttributeChanged(cTAStatusAttributeValue_);
    }
}

bool AVMServiceStubDefault::trySetCTAStatusAttribute(::v1::com::harman::adas::CTABaseType::stCTAStatus _value) {
    if (!validateCTAStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (cTAStatusAttributeValue_ != _value);
    cTAStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool AVMServiceStubDefault::validateCTAStatusAttributeRequestedValue(const ::v1::com::harman::adas::CTABaseType::stCTAStatus &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::adas::AVMBaseType::enAutoCaliState& AVMServiceStubDefault::getAutoStatusAttribute() {
    return autoStatusAttributeValue_;
}

const ::v1::com::harman::adas::AVMBaseType::enAutoCaliState& AVMServiceStubDefault::getAutoStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getAutoStatusAttribute();
}

void AVMServiceStubDefault::setAutoStatusAttribute(::v1::com::harman::adas::AVMBaseType::enAutoCaliState _value) {
    const bool valueChanged = trySetAutoStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<AVMServiceStubAdapter, AVMServiceStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireAutoStatusAttributeChanged(autoStatusAttributeValue_);
    }
}

bool AVMServiceStubDefault::trySetAutoStatusAttribute(::v1::com::harman::adas::AVMBaseType::enAutoCaliState _value) {
    if (!validateAutoStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (autoStatusAttributeValue_ != _value);
    autoStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool AVMServiceStubDefault::validateAutoStatusAttributeRequestedValue(const ::v1::com::harman::adas::AVMBaseType::enAutoCaliState &_value) {
    (void)_value;
	return _value.validate();
}



void AVMServiceStubDefault::SwitchAVMView(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::adas::AVMBaseType::enAVMViewMode _m_eAVMViewMode, SwitchAVMViewReply_t _reply) {
    (void)_client;
    (void) _m_eAVMViewMode;
    _reply();
}

void AVMServiceStubDefault::SwitchGuideline(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::adas::AVMBaseType::enAVMGuideLineMode _m_eAVMGuideLinewMode, SwitchGuidelineReply_t _reply) {
    (void)_client;
    (void) _m_eAVMGuideLinewMode;
    _reply();
}

void AVMServiceStubDefault::SwitchCTA(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::adas::CTABaseType::enCTAWorkMode _m_eCATMode, SwitchCTAReply_t _reply) {
    (void)_client;
    (void) _m_eCATMode;
    uint8_t iErrCTA = 0u;
    _reply(iErrCTA);
}

void AVMServiceStubDefault::SwitchAutoCalibrationAuto(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::adas::AVMBaseType::enAutoCaliWorkModeAuto _m_eAutoCaliMode, SwitchAutoCalibrationAutoReply_t _reply) {
    (void)_client;
    (void) _m_eAutoCaliMode;
    uint8_t iErrAutoCali = 0u;
    _reply(iErrAutoCali);
}

void AVMServiceStubDefault::SwitchAutoCalibrationManually(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::adas::AVMBaseType::enAutoCaliWorkModeManu _m_eAutoCaliMode, SwitchAutoCalibrationManuallyReply_t _reply) {
    (void)_client;
    (void) _m_eAutoCaliMode;
    uint8_t iErrAutoCali = 0u;
    _reply(iErrAutoCali);
}


void AVMServiceStubDefault::fireBcAVMViewStatusEvent(const ::v1::com::harman::adas::AVMBaseType::enAVMStatus &_m_AVMStatus) {
    if (!_m_AVMStatus.validate()) {
        return;
    }
    assert((CommonAPI::Stub<AVMServiceStubAdapter, AVMServiceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<AVMServiceStubAdapter, AVMServiceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireBcAVMViewStatusEvent(_m_AVMStatus);
}


AVMServiceStubDefault::RemoteEventHandler::RemoteEventHandler(AVMServiceStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace adas
} // namespace harman
} // namespace com
} // namespace v0
