/**
 * generated by DCIF CodeGen Version: R2_v2.3.0
 * generated on: Tue Aug 01 13:37:53 CST 2017
 */


/**
*This dependency management and build system (CMake)is only for reference.
*Please change it according to your project requirements.
*If required Please use your own dependency management and build system.
*/

_Generated files:_
==============================================================
Following is the directory structure of generated code for language type **_CPP_** 
and build type **_CMake_**.
		
	${ComponentName}
		+/gen
		+/src
		+/src-gen
		CMakeLists.txt 
		
1.***gen:***

	Directory contains all the RPC based consumer and provider CPP header files under provides
	and consumes directories respectively.It also contains CMakeLists.txt to build gen directory.
	
2.***src:***

	Directory contains **main.cpp ,provides directory and CMakeLists.txt.
			
	a).main.cpp contains the creation of objects.Following is block of 
	   code to call the APIs and signals using respective objects.
		
	b).Provides directory will be created only if component provides any interface.
	   It contains ${providesInterfaceName}StubImpl .cpp and .hpp files where user can implement business logic.
		
	c).CMakeLists.txt is used to build contents of src directory.
		
3).***src-gen:***

	a).Directory contains all the cpp,HPP files generated by CommonAPI and CMakeLists.txt.
	
	b).CMakeLists.txt used to build src-gen directory.
		
4).CMakeLists.txt is master CMake file to build component. 

_Building:_
==============================================================
1.Choose a directory where to build.

***command :***

		mkdir ${PWD}/build
			
2.Change to build directory

***command :***

		cd build
		
3.run cmake with SYSROOT as command line argument.

***command :***

		cmake -D CMAKE_SYSROOT=/path/to/your/sysroot/ /path/to/your/CMakeLists.txt

4.run make target to build the default implementation that is generated.
	
***command :***

		make

_Adding your business logic:_
==============================================================

1).Implement your business logic as follows.

	a).Open your ${providesInterfaceName}Impl.cpp which resides in your src/provides/ directory .

***e.g:***
			
	_v0_1/com/harman/voice/calculatorTesseractStubImpl.cpp_
	
b).Select API which you want to implement business logic.

	
```
	void calculatorTesseractStubImpl::add(const std::shared_ptr<CommonAPI::ClientId> _client, int32_t a, int32_t b, addReply_t reply)
	{
		int64_t sum = a + b;
		reply(sum);
		//if you have broadcast
		fireResultEvent(sum);
	}

```

Implementation businessLogic to call API :
------------------------------------------

1).Open your **_main.cpp_** which resides in your **_src_** directory.

2).Select the block of proxy interface which you want to implement.

***e.g.***


```

{
	std::string instance = "calcProvider.calculatorInstance";
	std::shared_ptr<v0_1::com::harman::voice::calculatorProxy<>> calculatorproxyInst = runtime->buildProxy<v0_1::com::harman::voice::calculatorProxy>
	(domain, instance, connection);
	if(!calculatorproxyInst)
	{
		
	}else{
		// Implementing signal.
		theScientificcalculatorProxy->getModeChangedEvent().subscribe(
			[&](const ::v0_1::com::harman::voice::scientificcalculator::enMode& message) {
			std::cout << "Received broadcast message: " << message << "\n";
	});
		Implement your business logic to call you api here.
		calculatorproxyInst->addition(augend,augend,callStatus,sum, &info);
	}
}

```
