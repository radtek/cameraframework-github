/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Mar 07 13:22:52 CST 2017
*/
#ifndef V0_ORG_HARMAN_FORD_baterrydata_types_HPP_
#define V0_ORG_HARMAN_FORD_baterrydata_types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace org {
namespace harman {
namespace ford {

struct baterrydata_types {
    
    struct Shed_Drain_Eng_Off_B_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            En_Active = 1,
            En_Inactive = 0
        };
        
        Shed_Drain_Eng_Off_B_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::En_Active)) {}
        Shed_Drain_Eng_Off_B_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::En_Active):
                case static_cast<int32_t>(Literal::En_Inactive):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Shed_Drain_Eng_Off_B_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Shed_Drain_Eng_Off_B_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Shed_Drain_Eng_Off_B_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Shed_Drain_Eng_Off_B_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Shed_Drain_Eng_Off_B_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Shed_Drain_Eng_Off_B_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Shed_T_Eng_Off_B_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            En_Active = 1,
            En_Inactive = 0
        };
        
        Shed_T_Eng_Off_B_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::En_Active)) {}
        Shed_T_Eng_Off_B_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::En_Active):
                case static_cast<int32_t>(Literal::En_Inactive):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Shed_T_Eng_Off_B_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Shed_T_Eng_Off_B_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Shed_T_Eng_Off_B_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Shed_T_Eng_Off_B_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Shed_T_Eng_Off_B_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Shed_T_Eng_Off_B_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Batt_Crit_SoC_B_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            En_Active = 1,
            En_Inactive = 0
        };
        
        Batt_Crit_SoC_B_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::En_Active)) {}
        Batt_Crit_SoC_B_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::En_Active):
                case static_cast<int32_t>(Literal::En_Inactive):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Batt_Crit_SoC_B_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Batt_Crit_SoC_B_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Batt_Crit_SoC_B_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Batt_Crit_SoC_B_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Batt_Crit_SoC_B_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Batt_Crit_SoC_B_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Batt_Lo_SoC_B_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            En_Active = 1,
            En_Inactive = 0
        };
        
        Batt_Lo_SoC_B_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::En_Active)) {}
        Batt_Lo_SoC_B_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::En_Active):
                case static_cast<int32_t>(Literal::En_Inactive):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Batt_Lo_SoC_B_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Batt_Lo_SoC_B_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Batt_Lo_SoC_B_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Batt_Lo_SoC_B_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Batt_Lo_SoC_B_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Batt_Lo_SoC_B_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Shed_Level_Req_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            En_SHED_ENG_OFF = 5,
            En_SOON_ENG_OFF = 4,
            En_SHED2_CONTIN = 3,
            En_SHED2_TRANS = 2,
            En_SHED1 = 1,
            En_NO_SHED = 0,
            En_Unused_2 = 7,
            En_Loads_On = 6
        };
        
        Shed_Level_Req_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::En_SHED_ENG_OFF)) {}
        Shed_Level_Req_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::En_SHED_ENG_OFF):
                case static_cast<int32_t>(Literal::En_SOON_ENG_OFF):
                case static_cast<int32_t>(Literal::En_SHED2_CONTIN):
                case static_cast<int32_t>(Literal::En_SHED2_TRANS):
                case static_cast<int32_t>(Literal::En_SHED1):
                case static_cast<int32_t>(Literal::En_NO_SHED):
                case static_cast<int32_t>(Literal::En_Unused_2):
                case static_cast<int32_t>(Literal::En_Loads_On):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Shed_Level_Req_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Shed_Level_Req_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Shed_Level_Req_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Shed_Level_Req_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Shed_Level_Req_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Shed_Level_Req_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct _Battery_Mgmt_2_struct : CommonAPI::Struct<Shed_Drain_Eng_Off_B_enum, Shed_T_Eng_Off_B_enum, Batt_Crit_SoC_B_enum, Batt_Lo_SoC_B_enum, Shed_Level_Req_enum> {
    	
    	_Battery_Mgmt_2_struct() {
    	}
    	_Battery_Mgmt_2_struct(const Shed_Drain_Eng_Off_B_enum &_shed_Drain_Eng_Off_B_enum, const Shed_T_Eng_Off_B_enum &_shed_T_Eng_Off_B_enum, const Batt_Crit_SoC_B_enum &_batt_Crit_SoC_B_enum, const Batt_Lo_SoC_B_enum &_batt_Lo_SoC_B_enum, const Shed_Level_Req_enum &_shed_Level_Req_enum)
    	{
    		std::get<0>(values_) = _shed_Drain_Eng_Off_B_enum;
    		std::get<1>(values_) = _shed_T_Eng_Off_B_enum;
    		std::get<2>(values_) = _batt_Crit_SoC_B_enum;
    		std::get<3>(values_) = _batt_Lo_SoC_B_enum;
    		std::get<4>(values_) = _shed_Level_Req_enum;
    	}
    	inline const Shed_Drain_Eng_Off_B_enum &getShed_Drain_Eng_Off_B_enum() const { return std::get<0>(values_); }
    	inline void setShed_Drain_Eng_Off_B_enum(const Shed_Drain_Eng_Off_B_enum &_value) { std::get<0>(values_) = _value; }
    	inline const Shed_T_Eng_Off_B_enum &getShed_T_Eng_Off_B_enum() const { return std::get<1>(values_); }
    	inline void setShed_T_Eng_Off_B_enum(const Shed_T_Eng_Off_B_enum &_value) { std::get<1>(values_) = _value; }
    	inline const Batt_Crit_SoC_B_enum &getBatt_Crit_SoC_B_enum() const { return std::get<2>(values_); }
    	inline void setBatt_Crit_SoC_B_enum(const Batt_Crit_SoC_B_enum &_value) { std::get<2>(values_) = _value; }
    	inline const Batt_Lo_SoC_B_enum &getBatt_Lo_SoC_B_enum() const { return std::get<3>(values_); }
    	inline void setBatt_Lo_SoC_B_enum(const Batt_Lo_SoC_B_enum &_value) { std::get<3>(values_) = _value; }
    	inline const Shed_Level_Req_enum &getShed_Level_Req_enum() const { return std::get<4>(values_); }
    	inline void setShed_Level_Req_enum(const Shed_Level_Req_enum &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const _Battery_Mgmt_2_struct& _other) const {
                return (getShed_Drain_Eng_Off_B_enum() == _other.getShed_Drain_Eng_Off_B_enum() && getShed_T_Eng_Off_B_enum() == _other.getShed_T_Eng_Off_B_enum() && getBatt_Crit_SoC_B_enum() == _other.getBatt_Crit_SoC_B_enum() && getBatt_Lo_SoC_B_enum() == _other.getBatt_Lo_SoC_B_enum() && getShed_Level_Req_enum() == _other.getShed_Level_Req_enum());
        }
    	inline bool operator!=(const _Battery_Mgmt_2_struct &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct BSBattSOC_UB_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            En_Fresh_data = 1,
            En_Unchanged_data = 0
        };
        
        BSBattSOC_UB_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::En_Fresh_data)) {}
        BSBattSOC_UB_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::En_Fresh_data):
                case static_cast<int32_t>(Literal::En_Unchanged_data):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const BSBattSOC_UB_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const BSBattSOC_UB_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const BSBattSOC_UB_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const BSBattSOC_UB_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const BSBattSOC_UB_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const BSBattSOC_UB_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct Battery_Mgmt_2_sig_0_struct : CommonAPI::Struct<uint8_t, BSBattSOC_UB_enum> {
    	
    	Battery_Mgmt_2_sig_0_struct() {
    	}
    	Battery_Mgmt_2_sig_0_struct(const uint8_t &_BSBattSOC, const BSBattSOC_UB_enum &_bSBattSOC_UB_enum)
    	{
    		std::get<0>(values_) = _BSBattSOC;
    		std::get<1>(values_) = _bSBattSOC_UB_enum;
    	}
    	inline const uint8_t &getBSBattSOC() const { return std::get<0>(values_); }
    	inline void setBSBattSOC(const uint8_t &_value) { std::get<0>(values_) = _value; }
    	inline const BSBattSOC_UB_enum &getBSBattSOC_UB_enum() const { return std::get<1>(values_); }
    	inline void setBSBattSOC_UB_enum(const BSBattSOC_UB_enum &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Battery_Mgmt_2_sig_0_struct& _other) const {
                return (getBSBattSOC() == _other.getBSBattSOC() && getBSBattSOC_UB_enum() == _other.getBSBattSOC_UB_enum());
        }
    	inline bool operator!=(const Battery_Mgmt_2_sig_0_struct &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.harman.ford.baterrydata_types";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(0, 1);
}

}; // struct baterrydata_types

} // namespace ford
} // namespace harman
} // namespace org
} // namespace v0

namespace CommonAPI {
}


namespace std {
    //Hash for Shed_Drain_Eng_Off_B_enum
    template<>
    struct hash<::v0::org::harman::ford::baterrydata_types::Shed_Drain_Eng_Off_B_enum> {
        inline size_t operator()(const ::v0::org::harman::ford::baterrydata_types::Shed_Drain_Eng_Off_B_enum& shed_Drain_Eng_Off_B_enum) const {
            return static_cast<int32_t>(shed_Drain_Eng_Off_B_enum);
        }
    };
    //Hash for Shed_T_Eng_Off_B_enum
    template<>
    struct hash<::v0::org::harman::ford::baterrydata_types::Shed_T_Eng_Off_B_enum> {
        inline size_t operator()(const ::v0::org::harman::ford::baterrydata_types::Shed_T_Eng_Off_B_enum& shed_T_Eng_Off_B_enum) const {
            return static_cast<int32_t>(shed_T_Eng_Off_B_enum);
        }
    };
    //Hash for Batt_Crit_SoC_B_enum
    template<>
    struct hash<::v0::org::harman::ford::baterrydata_types::Batt_Crit_SoC_B_enum> {
        inline size_t operator()(const ::v0::org::harman::ford::baterrydata_types::Batt_Crit_SoC_B_enum& batt_Crit_SoC_B_enum) const {
            return static_cast<int32_t>(batt_Crit_SoC_B_enum);
        }
    };
    //Hash for Batt_Lo_SoC_B_enum
    template<>
    struct hash<::v0::org::harman::ford::baterrydata_types::Batt_Lo_SoC_B_enum> {
        inline size_t operator()(const ::v0::org::harman::ford::baterrydata_types::Batt_Lo_SoC_B_enum& batt_Lo_SoC_B_enum) const {
            return static_cast<int32_t>(batt_Lo_SoC_B_enum);
        }
    };
    //Hash for Shed_Level_Req_enum
    template<>
    struct hash<::v0::org::harman::ford::baterrydata_types::Shed_Level_Req_enum> {
        inline size_t operator()(const ::v0::org::harman::ford::baterrydata_types::Shed_Level_Req_enum& shed_Level_Req_enum) const {
            return static_cast<int32_t>(shed_Level_Req_enum);
        }
    };
    //Hash for BSBattSOC_UB_enum
    template<>
    struct hash<::v0::org::harman::ford::baterrydata_types::BSBattSOC_UB_enum> {
        inline size_t operator()(const ::v0::org::harman::ford::baterrydata_types::BSBattSOC_UB_enum& bSBattSOC_UB_enum) const {
            return static_cast<int32_t>(bSBattSOC_UB_enum);
        }
    };
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_ORG_HARMAN_FORD_baterrydata_types_HPP_
