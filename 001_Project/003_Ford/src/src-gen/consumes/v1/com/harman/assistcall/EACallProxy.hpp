/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Mar 07 13:22:52 CST 2017
*/
/**
 * description: This is a Emergency Assitance Module  interface that is used by HMI and other
 *   module to 	   to get the EA supported features.
 * author: KHegde
 */
#ifndef V1_COM_HARMAN_ASSISTCALL_EA_Call_PROXY_HPP_
#define V1_COM_HARMAN_ASSISTCALL_EA_Call_PROXY_HPP_

#include <v1/com/harman/assistcall/EACallProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace assistcall {

template <typename ... _AttributeExtensions>
class EACallProxy
    : virtual public EACall, 
      virtual public EACallProxyBase,
      virtual public _AttributeExtensions... {
public:
    EACallProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~EACallProxy();

    typedef EACall InterfaceType;


    /**
     * description: EAFeatureName:          EAFeatureName: Type='STRING' Description='String value
     *   "911 Asssit" for US and for the           the rest of world  this is
     *   "Emergency Assistance"                                        This  attribute
     *   is used by HMI to display the  feature name the screen.
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute EAFeatureName.
     */
    virtual EAFeatureNameAttribute& getEAFeatureNameAttribute() {
        return delegate_->getEAFeatureNameAttribute();
    }
    /**
     * description: EAUserSettingState:          EAUserSettingState: Type='BOOL' Description='This
     *   is boolean  type for                         EA user setting status  '        
     *                                  This  attribute is set by HMI client 
     *   application to indicate the user setting of the          EA feature ON /OFF
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute EAUserSettingState.
     */
    virtual EAUserSettingStateAttribute& getEAUserSettingStateAttribute() {
        return delegate_->getEAUserSettingStateAttribute();
    }
    /**
     * description: EAEventFlag:          EAEventFlag: Type='BOOL' Description='This is boolean 
     *   type for                         EA Event  status'                            
     *              This read only attribute  can be used by client application to get 
     *   EA Event status            ( EA Event ON / EA Event OFF ) .
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute EAEventFlag.
     */
    virtual EAEventFlagAttribute& getEAEventFlagAttribute() {
        return delegate_->getEAEventFlagAttribute();
    }
    /**
     * description: EAOperationalState:          EAOperationalState: Type='BOOL' Description='This
     *   is boolean  type for                         EA operational status'           
     *                               This read only attribute  can be used by client
     *   application to get  EA operation status            ( EA Operational / EA Not
     *   operational ) .
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute EAOperationalState.
     */
    virtual EAOperationalStateAttribute& getEAOperationalStateAttribute() {
        return delegate_->getEAOperationalStateAttribute();
    }
    /**
     * description: EAFeatureAvailabilty:          EAFeatureAvailabilty: Type='BOOL'
     *   Description='This is boolean  type for                         EA Feature
     *   availabilty'                                        This read only attribute 
     *   can be used by client application to get  Enable or Dsiable EA Menu.
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute EAFeatureAvailability.
     */
    virtual EAFeatureAvailabilityAttribute& getEAFeatureAvailabilityAttribute() {
        return delegate_->getEAFeatureAvailabilityAttribute();
    }
    /**
     * description: EAEventStatus:          EAEventStatus: Type='eEAEventStatus' Description='This
     *   is enum type for                         Event Staus of the Emergency
     *   Assistance Behaviour'                                        This read only
     *   attribute  can be used by client application to get the systeminfo           
     *   deatils
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute EAEventStatus.
     */
    virtual EAEventStatusAttribute& getEAEventStatusAttribute() {
        return delegate_->getEAEventStatusAttribute();
    }
    /**
     * description: GPSData:          SystemInfo: Type='tsGPSData' Description='This is structure
     *   type for the GPS Data'                                        This read only
     *   attribute  can be used by client application to get the GPS Lattitude and
     *   Longitude
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute gpsData.
     */
    virtual GpsDataAttribute& getGpsDataAttribute() {
        return delegate_->getGpsDataAttribute();
    }
    /**
     * description: eaKeyType:          eaKeyType: Type='eKeyType' Description='This is enum type
     *   for key system'                                        This read only
     *   attribute  can be used by HMI client to get the info            type of key
     *   system in the car.
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute eaKeyType.
     */
    virtual EaKeyTypeAttribute& getEaKeyTypeAttribute() {
        return delegate_->getEaKeyTypeAttribute();
    }
    /**
     * description: EAOperationalStatus:          EAOperationalState: Type='eEAOperationStatus'
     *   Description='This is enum  type for                         EA operational
     *   status'                                        This read only attribute  can
     *   be used by client application to get  EA operation status            (EA
     *   operational Default Unknown /EA Operational / EA Not operational ) .
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute EAOperationalStatus.
     */
    virtual EAOperationalStatusAttribute& getEAOperationalStatusAttribute() {
        return delegate_->getEAOperationalStatusAttribute();
    }
    /**
     * description: GPSLatLonData:          SystemInfo: Type='GPSLatLonData' Description='This is
     *   structure type for the GPS Lat /Lon  Data'                                    
     *      This read only attribute  can be used by client application to get the GPS
     *   Lattitude and Longitude
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the attribute gpsLatLonData.
     */
    virtual GpsLatLonDataAttribute& getGpsLatLonDataAttribute() {
        return delegate_->getGpsLatLonDataAttribute();
    }

    /**
     * description: notifyTMessageID:          PmessageID: Type='eTMessageType' ; Description='This
     *   is the                          transient  message id to be used by HMI
     *   client'                           This signal can be used by HMI client to be
     *   notified about           HMI Transient  Message ID during the EA event
     *   behaviour
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the broadcast notifyTMessageID.
     */
    virtual NotifyTMessageIDEvent& getNotifyTMessageIDEvent() {
        return delegate_->getNotifyTMessageIDEvent();
    }
    /**
     * description: notifyPMessageID:          PmessageID: Type='ePMessageType' ; Description='This
     *   is the                          pop up message id to be used by HMI client'   
     *                          This signal can be used by HMI client to be notified
     *   about           HMI pop up Message ID during the EA event behaviour
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the broadcast notifyPMessageID.
     */
    virtual NotifyPMessageIDEvent& getNotifyPMessageIDEvent() {
        return delegate_->getNotifyPMessageIDEvent();
    }
    /**
     * description: notifyToTerminateTM :          TmessageID: Type='eTMessageType' ;
     *   Description='This is the                          transient  message id to be
     *   used by HMI client to terminate if  it is displayed.'                         
     *    This signal is a broadcast notify from EA to HMI  to terminate            HMI
     *   TM Message displayed . TM Message shall be a previous request from EA.
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the broadcast notifyToTerminateTM.
     */
    virtual NotifyToTerminateTMEvent& getNotifyToTerminateTMEvent() {
        return delegate_->getNotifyToTerminateTMEvent();
    }
    /**
     * description: notifyEACallCancelTimer:          rTimeInSeconds: Type='UInt8' ;
     *   Description='This is the                            remaining time of
     *   cancellation timer pop up screen'          totalTimeInSeconds: Type='UInt8' ;
     *   Description='This is the                            total time of cancellation
     *   Timer pop up screen'
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the broadcast notifyEACallCancelTimer.
     */
    virtual NotifyEACallCancelTimerEvent& getNotifyEACallCancelTimerEvent() {
        return delegate_->getNotifyEACallCancelTimerEvent();
    }
    /**
     * description: notifyTTSPlayTermination:          domain : Type = 'String' ;Description =
     *   'This is to identify the           currently playing prompt channel for which
     *   cancel request has           been sent to TTS'
     * author: KHegde
     */
    /**
     * Returns the wrapper class that provides access to the broadcast notifyCancelTTSPlay.
     */
    virtual NotifyCancelTTSPlayEvent& getNotifyCancelTTSPlayEvent() {
        return delegate_->getNotifyCancelTTSPlayEvent();
    }

    /**
     * description: cancelRequestConfirm:          errorCode: Type='eErrorCode' Description='This
     *   is the                          return value of the method call '             
     *                This method can be used by HMI client to cancel           EA
     *   event behaviour
     * author: KHegde
     * Calls cancelRequest with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void cancelRequest(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::assistcall::EACallTypedefs::eErrorCode &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls cancelRequest with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> cancelRequestAsync(CancelRequestAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: cancelRequestConfirm:          errorCode: Type='eErrorCode' Description='This
     *   is the                          return value of the method call '             
     *                This method can be used by HMI client to confirm the user        
     *      request for the cancel EA event behaviour
     * author: KHegde
     * Calls cancelRequestConfirm with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void cancelRequestConfirm(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::assistcall::EACallTypedefs::eErrorCode &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls cancelRequestConfirm with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> cancelRequestConfirmAsync(CancelRequestConfirmAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: hmiRequestStartEACall:          errorCode: Type='eErrorCode' Description='This
     *   is the                          return value of the method call '             
     *                This method can be used by HMI to start the EA call when user
     *   selects "NO" in             cancel confirmation pop up.
     * author: KHegde
     * Calls hmiRequestStartEACall with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hmiRequestStartEACall(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::assistcall::EACallTypedefs::eErrorCode &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hmiRequestStartEACall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hmiRequestStartEACallAsync(HmiRequestStartEACallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<EACallProxyBase> delegate_;
};

typedef EACallProxy<> EACallProxyDefault;

namespace EACallExtensions {
    /**
     * description: EAFeatureName:          EAFeatureName: Type='STRING' Description='String value
     *   "911 Asssit" for US and for the           the rest of world  this is
     *   "Emergency Assistance"                                        This  attribute
     *   is used by HMI to display the  feature name the screen.
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class EAFeatureNameAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::EAFeatureNameAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::EAFeatureNameAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EAFeatureNameAttributeExtension() {}
    #endif
    
        EAFeatureNameAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getEAFeatureNameAttribute()) {
        }
    
        inline extension_type& getEAFeatureNameAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: EAUserSettingState:          EAUserSettingState: Type='BOOL' Description='This
     *   is boolean  type for                         EA user setting status  '        
     *                                  This  attribute is set by HMI client 
     *   application to indicate the user setting of the          EA feature ON /OFF
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class EAUserSettingStateAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::EAUserSettingStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::EAUserSettingStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EAUserSettingStateAttributeExtension() {}
    #endif
    
        EAUserSettingStateAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getEAUserSettingStateAttribute()) {
        }
    
        inline extension_type& getEAUserSettingStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: EAEventFlag:          EAEventFlag: Type='BOOL' Description='This is boolean 
     *   type for                         EA Event  status'                            
     *              This read only attribute  can be used by client application to get 
     *   EA Event status            ( EA Event ON / EA Event OFF ) .
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class EAEventFlagAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::EAEventFlagAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::EAEventFlagAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EAEventFlagAttributeExtension() {}
    #endif
    
        EAEventFlagAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getEAEventFlagAttribute()) {
        }
    
        inline extension_type& getEAEventFlagAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: EAOperationalState:          EAOperationalState: Type='BOOL' Description='This
     *   is boolean  type for                         EA operational status'           
     *                               This read only attribute  can be used by client
     *   application to get  EA operation status            ( EA Operational / EA Not
     *   operational ) .
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class EAOperationalStateAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::EAOperationalStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::EAOperationalStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EAOperationalStateAttributeExtension() {}
    #endif
    
        EAOperationalStateAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getEAOperationalStateAttribute()) {
        }
    
        inline extension_type& getEAOperationalStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: EAFeatureAvailabilty:          EAFeatureAvailabilty: Type='BOOL'
     *   Description='This is boolean  type for                         EA Feature
     *   availabilty'                                        This read only attribute 
     *   can be used by client application to get  Enable or Dsiable EA Menu.
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class EAFeatureAvailabilityAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::EAFeatureAvailabilityAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::EAFeatureAvailabilityAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EAFeatureAvailabilityAttributeExtension() {}
    #endif
    
        EAFeatureAvailabilityAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getEAFeatureAvailabilityAttribute()) {
        }
    
        inline extension_type& getEAFeatureAvailabilityAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: EAEventStatus:          EAEventStatus: Type='eEAEventStatus' Description='This
     *   is enum type for                         Event Staus of the Emergency
     *   Assistance Behaviour'                                        This read only
     *   attribute  can be used by client application to get the systeminfo           
     *   deatils
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class EAEventStatusAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::EAEventStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::EAEventStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EAEventStatusAttributeExtension() {}
    #endif
    
        EAEventStatusAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getEAEventStatusAttribute()) {
        }
    
        inline extension_type& getEAEventStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: GPSData:          SystemInfo: Type='tsGPSData' Description='This is structure
     *   type for the GPS Data'                                        This read only
     *   attribute  can be used by client application to get the GPS Lattitude and
     *   Longitude
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class GpsDataAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::GpsDataAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::GpsDataAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        GpsDataAttributeExtension() {}
    #endif
    
        GpsDataAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getGpsDataAttribute()) {
        }
    
        inline extension_type& getGpsDataAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: eaKeyType:          eaKeyType: Type='eKeyType' Description='This is enum type
     *   for key system'                                        This read only
     *   attribute  can be used by HMI client to get the info            type of key
     *   system in the car.
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class EaKeyTypeAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::EaKeyTypeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::EaKeyTypeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EaKeyTypeAttributeExtension() {}
    #endif
    
        EaKeyTypeAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getEaKeyTypeAttribute()) {
        }
    
        inline extension_type& getEaKeyTypeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: EAOperationalStatus:          EAOperationalState: Type='eEAOperationStatus'
     *   Description='This is enum  type for                         EA operational
     *   status'                                        This read only attribute  can
     *   be used by client application to get  EA operation status            (EA
     *   operational Default Unknown /EA Operational / EA Not operational ) .
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class EAOperationalStatusAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::EAOperationalStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::EAOperationalStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EAOperationalStatusAttributeExtension() {}
    #endif
    
        EAOperationalStatusAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getEAOperationalStatusAttribute()) {
        }
    
        inline extension_type& getEAOperationalStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: GPSLatLonData:          SystemInfo: Type='GPSLatLonData' Description='This is
     *   structure type for the GPS Lat /Lon  Data'                                    
     *      This read only attribute  can be used by client application to get the GPS
     *   Lattitude and Longitude
     * author: KHegde
     */
    template <template <typename > class _ExtensionType>
    class GpsLatLonDataAttributeExtension {
     public:
        typedef _ExtensionType<EACallProxyBase::GpsLatLonDataAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<EACallProxyBase::GpsLatLonDataAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        GpsLatLonDataAttributeExtension() {}
    #endif
    
        GpsLatLonDataAttributeExtension(EACallProxyBase& proxy): attributeExtension_(proxy.getGpsLatLonDataAttribute()) {
        }
    
        inline extension_type& getGpsLatLonDataAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace EACallExtensions

//
// EACallProxy Implementation
//
template <typename ... _AttributeExtensions>
EACallProxy<_AttributeExtensions...>::EACallProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<EACallProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<EACallProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
EACallProxy<_AttributeExtensions...>::~EACallProxy() {
}

/**
 * description: cancelRequestConfirm:          errorCode: Type='eErrorCode' Description='This
 *   is the                          return value of the method call '             
 *                This method can be used by HMI client to cancel           EA
 *   event behaviour
 * author: KHegde
 */
template <typename ... _AttributeExtensions>
void EACallProxy<_AttributeExtensions...>::cancelRequest(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::assistcall::EACallTypedefs::eErrorCode &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->cancelRequest(_internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> EACallProxy<_AttributeExtensions...>::cancelRequestAsync(CancelRequestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->cancelRequestAsync(_callback, _info);
}
/**
 * description: cancelRequestConfirm:          errorCode: Type='eErrorCode' Description='This
 *   is the                          return value of the method call '             
 *                This method can be used by HMI client to confirm the user        
 *      request for the cancel EA event behaviour
 * author: KHegde
 */
template <typename ... _AttributeExtensions>
void EACallProxy<_AttributeExtensions...>::cancelRequestConfirm(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::assistcall::EACallTypedefs::eErrorCode &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->cancelRequestConfirm(_internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> EACallProxy<_AttributeExtensions...>::cancelRequestConfirmAsync(CancelRequestConfirmAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->cancelRequestConfirmAsync(_callback, _info);
}
/**
 * description: hmiRequestStartEACall:          errorCode: Type='eErrorCode' Description='This
 *   is the                          return value of the method call '             
 *                This method can be used by HMI to start the EA call when user
 *   selects "NO" in             cancel confirmation pop up.
 * author: KHegde
 */
template <typename ... _AttributeExtensions>
void EACallProxy<_AttributeExtensions...>::hmiRequestStartEACall(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::assistcall::EACallTypedefs::eErrorCode &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->hmiRequestStartEACall(_internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> EACallProxy<_AttributeExtensions...>::hmiRequestStartEACallAsync(HmiRequestStartEACallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hmiRequestStartEACallAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &EACallProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool EACallProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool EACallProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& EACallProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& EACallProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace assistcall
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::com::harman::assistcall::EACallProxy,
    _AttributeExtension> {
    typedef typename ::v1::com::harman::assistcall::EACallProxy<
            ::v1::com::harman::assistcall::EACallExtensions::EAFeatureNameAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::EAUserSettingStateAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::EAEventFlagAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::EAOperationalStateAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::EAFeatureAvailabilityAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::EAEventStatusAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::GpsDataAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::EaKeyTypeAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::EAOperationalStatusAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::assistcall::EACallExtensions::GpsLatLonDataAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_ASSISTCALL_EA_Call_PROXY_HPP_
