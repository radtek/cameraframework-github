/**
 * generated by Voice CodeGen Version: R1_v1.3.0
 * generated on: Fri Nov 04 18:01:09 IST 2016
 */
using namespace std;
#include "ParkAssistSrv_RVC/RVCServiceStubImpl.hpp"
#include "ParkAssistSrv_Common/CPresCoreHandler.hpp"

namespace v0 {
namespace com {
namespace harman {
namespace ParkAssist {

RVCServiceStubImpl::RVCServiceStubImpl(CContext *p_pobjContext) :
m_GearFault(false),
m_CameraMaxSpeed(false),
m_NsmSessionState(false),
m_IsTimerRunning(false),
m_ParkBrakeStatus(false),
m_VehParked(false),
m_APASysAcess(false),
m_APAGearStatus(false),
m_Ignitionoff(false),
m_ReverseGearStatus(false),
m_CancelIconPresed(false),
m_pobjContext(p_pobjContext)
{
    //Initilizing attribute with default value
    LOG_INFO(LOG_RVC,"RVCServiceStubImpl Constructor ");
    if((m_pobjContext !=NULL) && (m_pobjContext->m_bContextIsRVCSupported == true))
    {
        setRVCZoomOnOffAttribute(ParkAssistBaseType::enRVCZoom::RVC_Zoom_Off_Request); //After PAM is up , Request zoom as off  as per as requirement
        setRVCSpiltViewOnOffAttribute(ParkAssistBaseType::enRVCSplitView::RVC_SplitView_Off_Request);
        setRVCTrunkStatusAttribute(false);  //Initial value of Trunk status will be off
        setRVCDisPlayStatusAttribute(ParkAssistBaseType::enRVCStatus::RVC_Off); //Initial value of display status will be off
        setRVCErrorAttribute(ParkAssistBaseType::enRVCError::RVC_noError); 
        setDisplayIconTypeAttribute(ParkAssistBaseType::enDisplayIconType::e_ZOOM_ICON);
        
        //Reading Data from persistence and setting attribute according to data
        //Default value of camera delay will be off
        //Default Value of Enhanced park aid  be on
        //Persistence default value will be 0 for enhanced park aid . But according to spec enhanced park aid default value will be 1.so write m_bIsEnahancedParkAidOn as 0 to persistence when enhanced park aid is on
        m_pobjContext->m_bIsEnahancedParkAidOn = !m_pobjContext->m_bIsEnahancedParkAidOn;
        LOG_INFO(LOG_RVC, "Camera delay :%d Enhanced Park Setting: %d \n", m_pobjContext->m_bIsCameraDealyOn,m_pobjContext->m_bIsEnahancedParkAidOn);
        setRVCEnhancedPrkAidAttribute(m_pobjContext->m_bIsEnahancedParkAidOn);
        setCameraDelayOnOffAttribute(m_pobjContext->m_bIsCameraDealyOn);
        m_ManualGear = UNKNOWN;
     
    }
    else
    {
         setRVCDisPlayStatusAttribute(ParkAssistBaseType::enRVCStatus::RVC_NOT_CONFIGURED); //Initial value of display status will be off
        //Camera is not configured . Set the attribute to indicate camera is not configured
    
    }
}

void RVCServiceStubImpl::InitializeRVCStub()
{

      // start the background thread
    if(m_pobjContext->m_bContextIsRVCSupported)
    {
        LOG_INFO(LOG_RVC,"RVCServiceStubImpl Intialize called");
        
         //Function binding required for camera delay timer callback
        tCameraDelaycbk = std::bind( &RVCServiceStubImpl::CameraDelayTimerExpired, this );
        
        m_ThreadExit =false;  // Initializing Thread Variable
        //Creating nano msg thread to achive IPC between PAM and ford video app
        m_NanoMsgThread = thread{&RVCServiceStubImpl::NanoMsgListner,this};
    }   

}


RVCServiceStubImpl::~RVCServiceStubImpl()
{
    LOG_INFO(LOG_RVC,"RVCServiceStubImpl Destructor called");
    //to kill the message queue and nano message thread
    Deinitilize();
}
void RVCServiceStubImpl::CameraDelayTimerExpired()
{
    //Callback after 2 seconds for camera delay on setting
    //Switch off the camera if vehicle speed crosses 10km/hr 
    LOG_INFO(LOG_RVC,"camera delay call back after 2 seconds");
    RVCOffRequestonCameradelay();
    
}


/**
    @brief Call back from Common API whenever Zoom attribute is changed by HMI
    @param : None
*/
void RVCServiceStubImpl::onRemoteRVCZoomOnOffAttributeChanged()
{
    LOG_INFO(LOG_RVC,"RVCServiceStubImpl Zoom Attribute Changed");
    //Post the message To PresCore
    if(m_pobjContext->m_bContextIsRVCSupported)
    {
        EParkAssistReqId l_eReqId = e_ParkAssist_RVC_ZOOM_REQUEST;
        CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
    } 
 
}

/**
    @brief Call back from Common API whenever SpiltViewOnOff Attribute is changed by HMI
    @param : None
*/
void RVCServiceStubImpl::onRemoteRVCSpiltViewOnOffAttributeChanged()
{
    if(m_pobjContext->m_bContextIsRVCSupported)
    {
        LOG_INFO(LOG_RVC,"RVCServiceStubImpl SplitView Attribute Changed");
        EParkAssistReqId l_eReqId = e_ParkAssist_RVC_SPLITVIEW_REQUEST;
        CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
    }   

}

/**
    @brief Call back from Common API whenever Enhanced mode  Attribute is changed by HMI
    @param : None
*/
void RVCServiceStubImpl::onRemoteRVCEnhancedPrkAidAttributeChanged()
{
    bool l_bEhcViewReq = false;
    if(m_pobjContext->m_bContextIsRVCSupported)
    {
        LOG_INFO(LOG_RVC,"RVCServiceStubImpl EnhancedPrkAid Attribute Changed");
        
        //Write the Enhanced park aid data into persistence
        l_bEhcViewReq = getRVCEnhancedPrkAidAttribute();
        //Persistence default value will be 0 for enhanced park aid . But according to spec enhanced park aid default value will be 1.so write m_bIsEnahancedParkAidOn as 0 to persistence when enhanced park aid is on
        m_pobjContext->m_bIsEnahancedParkAidOn = !l_bEhcViewReq;
        m_pobjContext->WriteDataToPersistency(e_Persistency_EnhancedMode);
        //Post the message on message queue and release the dbus thread
        LOG_INFO(LOG_RVC,"Enhanced mode request m_pobjContext->m_bIsEnahancedParkAidOn :%d l_bEhcViewReq:%d ",m_pobjContext->m_bIsEnahancedParkAidOn,l_bEhcViewReq);
        EParkAssistReqId l_eReqId = e_ParkAssist_RVC_ENHANCEDMODE_REQUEST;
        CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
    }   

}

/**
    @brief Call back from Common API whenever CameraDelayOnOff Attribute is changed by HMI
    @param : None
*/
void RVCServiceStubImpl::onRemoteCameraDelayOnOffAttributeChanged()
{
    LOG_INFO(LOG_RVC,"RVCServiceStubImpl eCameraDelayOnOff Attribute Changed");
    //Updating camera delay data member . It's required to handle RVC switch off use case 
    //If the camera delay variable is on, monitor vehicle speed and wait till it crosses 10kmph to switch the camera
   
    if(NULL != m_pobjContext)
    {
        m_pobjContext->m_bIsCameraDealyOn = getCameraDelayOnOffAttribute();
        m_pobjContext->WriteDataToPersistency(e_Persistency_CameraDelay);
    }
    LOG_INFO(LOG_RVC, "onRemoteCheckAttributeChanged and value is %d", m_pobjContext->m_bIsCameraDealyOn);
   
}


/**
    @brief Distance bar setting callback from AMB to indicate initial or updated value of Enhanced mode 
    @param  uint16_t
*/
void RVCServiceStubImpl::CamPDCGuidStat(uint16_t PDCGuidStat)
{
//To Do Implement ion
    switch (PDCGuidStat)
    {
        case camerainfo_types::CamPDCGuidStat_enum::En_Invalid:
            LOG_INFO(LOG_RVC,"CamPDCGuidStat is invalid ");
             break;
        case camerainfo_types::CamPDCGuidStat_enum::En_Active:
            //inform HMI that enhanced mode is active
         //   setRVCEnhancedPrkAidAttribute(ParkAssistBaseType::enRVCEnhancedPrkAid::RVC_PrkAid_on_Completed);
            LOG_INFO(LOG_RVC,"CamPDCGuidStat is Active ");
            break;
        case camerainfo_types::CamPDCGuidStat_enum::En_Inactive:
            //inform HMI that enhanced mode is Deactive
           // setRVCEnhancedPrkAidAttribute(ParkAssistBaseType::enRVCEnhancedPrkAid::RVC_PrkAid_off_Completed);
            LOG_INFO(LOG_RVC,"CamPDCGuidStat is Inactive ");
             break;
        case camerainfo_types::CamPDCGuidStat_enum::En_Not_Used:
            LOG_INFO(LOG_RVC,"CamPDCGuidStat is Not_Used ");
             break;
        default:
            LOG_INFO(LOG_RVC,"CamPDCGuidStat Default use case");
    }

}

/**
    @brief Dyanamic overlay callback from AMB to indicate updated value
    @param  uint16_t
 */
void RVCServiceStubImpl::CamraOvrlDyn(uint16_t CamraOvrDyn)
{
//Call back status from ECU  to inform whether camera dynamic overlay is enabled on RVC image . No need to take any action
    switch (CamraOvrDyn)
    {
        case camerainfo_types::CamraOvrlDyn_D_Actl_enum::En_Invalid:
             LOG_INFO(LOG_RVC,"CamraOvrlDyn is Invalid");
             break;
        case camerainfo_types::CamraOvrlDyn_D_Actl_enum::En_Active:
            LOG_INFO(LOG_RVC,"CamraOvrlDyn is Active");
             break;
        case camerainfo_types::CamraOvrlDyn_D_Actl_enum::En_Inactive:
            LOG_INFO(LOG_RVC,"CamraOvrlDyn is Inactive");
             break;
        case camerainfo_types::CamraOvrlDyn_D_Actl_enum::En_Not_Used:
            LOG_INFO(LOG_RVC,"CamraOvrlDyn is Not_Used");
             break;
        default:
            LOG_INFO(LOG_RVC,"CamraOvrlDyn Default usecase");
            
    }

}

/**
    @brief static  overlay callback from AMB to indicate updated value
    @param  uint16_t
 */
void RVCServiceStubImpl::CamraOvrlStat(uint16_t CamraOvrStat)
{
//Call back status from ECU  to inform whether camera static overlay is enabled on RVC image . No need to take any action
    switch (CamraOvrStat)
    {
        case camerainfo_types::CamraOvrlStat_D_Actl_enum::En_Invalid:
             LOG_INFO(LOG_RVC,"CamraOvrlStat is Invalid");
             break;
        case camerainfo_types::CamraOvrlStat_D_Actl_enum::En_Active:
            LOG_INFO(LOG_RVC,"CamraOvrlStat is Active");
             break;
        case camerainfo_types::CamraOvrlStat_D_Actl_enum::En_Inactive:
            LOG_INFO(LOG_RVC,"CamraOvrlStat is Inactive");
            break;
        case camerainfo_types::CamraOvrlStat_D_Actl_enum::En_Not_Used:
            LOG_INFO(LOG_RVC,"CamraOvrlStat is Not_Used");
            break;
        default:
            LOG_INFO(LOG_RVC,"CamraOvrlStat Default usecase");
    }

}

    
/**
    @briefNotification to indicate Current Gear position of vehicle and conversion related to HMI values
    @param  TransmissionModeExtension - Enum value for different gear position.
 */ 
void RVCServiceStubImpl::NotifyGearPostion(bodycontroldata_types::GearLvrPos_D_Actl_enum PtrGearPostion)
{

    m_VehParked = false;
    m_GearFault = false;
    switch(PtrGearPostion)
    {
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_Park:
            LOG_INFO(LOG_RVC,"Current Gear status is Parked");
            m_VehParked = true;
            m_ReverseGearStatus = false;
            //Switch off the camera for vehicle enter into parking mode 
            RVCSwitchOffCamera();
            break;
            
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_Reverse:
            m_GearFault = false;
            m_ReverseGearStatus = true;
            LOG_INFO(LOG_RVC,"Current Gear status is Reverse");
            break;
            
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_Fault:
            m_GearFault = true;
            LOG_INFO(LOG_RVC,"Current Gear status is fault");
            
            break;
            
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_first:
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_second:
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_third:
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_fourth:
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_fifth:
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_sixth:
            m_ReverseGearStatus = false;
             LOG_INFO(LOG_RVC,"Current Gear status is forward");
            break;
        
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_Undefined_Treat_as_Fault1:
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_Undefined_Treat_as_Fault:  
        case bodycontroldata_types::GearLvrPos_D_Actl_enum::En_Unknown_Position:    
            LOG_INFO(LOG_RVC,"Current Gear status is undefined fault");
            break;      
        
        default:
            m_ReverseGearStatus = false;        
            LOG_INFO(LOG_RVC,"Current Gear status is unknown");
    
    }
    //Handling gear fault for auto transmission
    NotifyGearStatus();

}

/**
    @brief Notification to indicate Park brake status  and conversion related to HMI values
    @param  PtrGearPostion - Enum value for different Park Brake status.
*/
void RVCServiceStubImpl::NotifyParkBrkStatus(enginedata_types::PrkBrkActv_B_Actl_enum p_ePrkBrkStatus)
{
//To do implement
    LOG_INFO(LOG_RVC,"NotifyParkBrkStatus from AMB ");
    switch (p_ePrkBrkStatus)
    {
        case enginedata_types::PrkBrkActv_B_Actl_enum::En_Active:
            //Mechanical Gear is Active on Manual Transmission
            m_ParkBrakeStatus = true;
            LOG_INFO(LOG_RVC,"NotifyParkBrkStatus is active ");
            //Determining whether vehicle enter into Parking mode
            CalculateGearStatus();
            break;
        case enginedata_types::PrkBrkActv_B_Actl_enum::En_Inactive:
            //Mechanical Gear is Inactive on Manual Transmission
            m_ParkBrakeStatus = false;
            LOG_INFO(LOG_RVC,"NotifyParkBrkStatus is Inactive ");
            //Determining whether vehicle enter into Parking mode
            CalculateGearStatus();
            break;
        default:
            LOG_INFO(LOG_RVC,"NotifyParkBrkStatus default usecase");
    }

}

void RVCServiceStubImpl::ProcessElecBrkStatuResponce(enginedata_types::PrkBrkStatus_enum p_eElcPrkBrkStatus)
{
    LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce from AMB ");
    //Need customer clarification to find out active and inactive state
   /* switch (p_eElcPrkBrkStatus)
    {
        case enginedata_types::PrkBrkStatus_enum::En_GeneralFault_MaintenceMode:
        LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce is MaintenceMode ");
        break;
        case enginedata_types::PrkBrkStatus_enum::En_ECD_by_Brake_ECU_Active:
        LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce is ECD_by_Brake_ECU_Active ");
        break;
        case enginedata_types::PrkBrkStatus_enum::En_EPB_Limphome_Active:
        LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce is Limphome_Active ");
        break;
        case enginedata_types::PrkBrkStatus_enum::En_Rear_Caliper_Open:
        LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce is En_Rear_Caliper_Open ");
        break;
        case enginedata_types::PrkBrkStatus_enum::En_RWU_By_EPB_Active:
        LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce is En_RWU_By_EPB_Active ");
        break;
        case enginedata_types::PrkBrkStatus_enum::En_Rear_Caliper_Transition:
        LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce is En_Rear_Caliper_Transition ");
        break;
        case enginedata_types::PrkBrkStatus_enum::En_Rear_Caliper_Closed:
        LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce is En_Rear_Caliper_Closed ");
        break;
        case enginedata_types::PrkBrkStatus_enum::En_Not_Used:
        LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce is :En_Not_Used ");
        break;
        default:
            LOG_INFO(LOG_RVC,"ProcessElecBrkStatuResponce default usecase");
    }*/


}


/**
    @brief :IPC thread to listen message from diffrent process 
    @param  None
 */
void RVCServiceStubImpl::NanoMsgListner()
{
    do
    {
        int MessageType = 0;
        int iReturn = -1;
        int l_uintBytesWritten = 0;
        m_Socket = ConnectToNanoMsgHost() ;
        if(-1 == m_Socket)
        {
            LOG_INFO(LOG_RVC,"ConnectToNanoMsgHost Failed... ");
            break;
        }
        
        //Make sure that connection with server is achieved
        iReturn = NanoMsgHandShake(m_Socket);
        if(-1 == iReturn)
        {
            LOG_INFO(LOG_RVC,"NanoMsgHandShaked is failed");
            break;

            //To do handle error usecase
            
        }
        
        //Telling Ford Video APP that PAM is Available
        l_uintBytesWritten = SendNanoMessage(m_Socket,RVC_GET_STATUS);

        cout << "Atita Sent Bytes are ::" << l_uintBytesWritten ;
        LOG_INFO(LOG_RVC,"Requesting RVC status from Video APP");
        
        if (m_Socket >= 0)
        {
            while(!m_ThreadExit)
            {
                LOG_INFO(LOG_RVC,"Waiting to Receive the data Ford Video App");
                //Recv the msgs from ford video app
                MessageType = RecvNanoMessage(m_Socket);
                LOG_INFO(LOG_RVC,"Received the data Ford Video App");
                if (MessageType >0)
                {
                    ProcessNanoMessage(MessageType);
                    //To do check condition to comeback from loop
                }
                else if( MessageType == -1)
                {
                    //Not recovered error and to be come out of loop
                    LOG_INFO(LOG_RVC,"Connection is closed by Server");
                    break;
                
                }
        
            }
        
        }
        CloseNanoMsgConnection(m_Socket);
    }while(0);

}

/**
    @brief Taking required action after receiving IPC messages from ford video app 
 */

void RVCServiceStubImpl::ProcessNanoMessage(int MsgType)
{
    LOG_INFO(LOG_RVC,"ProcessNanoMessage for video App :%d",MsgType);
    EParkAssistReqId l_eReqId = e_ParkAssist_MANAGE_SCREEN_POSITION;
    switch(MsgType)
    {
        case RVC_SCREEN_ON:
        {
            LOG_INFO(LOG_RVC,"RECEIVED RVC_SCREEN_ON From RVC service \n");
            //Received RVC on message from FORD video APP
            //Informing HMI that camera is switched ON
            //Reset the error variable to no error
            setRVCErrorAttribute(ParkAssistBaseType::enRVCError::RVC_noError); 
            setRVCDisPlayStatusAttribute(ParkAssistBaseType::enRVCStatus::RVC_On);
            ZoomIconOnOff(true);
            if(NULL != m_pobjContext)
            {
                m_pobjContext->m_bIsRVCOn = true;
            }
            CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);            

         }
            break;
        case RVC_SCREEN_OFF:
            {
                //Received RVC OFF message from FORD video APP
                //Informing HMI that camera is switched off
              
                LOG_INFO(LOG_RVC,"RECEIVED RVC_SCREEN_Off From RVC service \n");
                if((m_GearFault) && ( ParkAssistBaseType::enRVCStatus::RVC_On == getRVCDisPlayStatusAttribute()))
                {
                    setRVCErrorAttribute(ParkAssistBaseType::enRVCError::RVC_GearFAULT);
                    LOG_INFO(LOG_RVC,"RVC Gear fault Happeneds \n");
                }

                ZoomIconOnOff(true);
                setRVCDisPlayStatusAttribute(ParkAssistBaseType::enRVCStatus::RVC_Off);
                if(NULL != m_pobjContext)
                {
                    m_pobjContext->m_bIsRVCOn = false;
                }
                CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
            }
            break;
        case SWITCH_OFF_RVC_REQ:
            {
                LOG_INFO(LOG_RVC,"RECEIVED SWICTH_OFF_RVC_REQ From RVC service \n");
                //Received RVC OFF Request from ford video app
                //If camera delay is on , Wait for vehicle to cross 10km/hr and inform Ford video app to switch off the camera
                //If camera delay is off ,Inform Ford video app to switch off the camera
                //Ford video app requesting to switch off the camera but reason behind switch off the camera will be provided by AMB
                WaitForAMBUpdate();
                ProcessRVCOffRequest();
            
            }
            break;
        case RVC_NO_SIGNAL:
            {
                //Camera is disconnected or malfunctioned
                //Inform HMI to display the message
                LOG_INFO(LOG_RVC,"No signal from camera \n");
                setRVCErrorAttribute(ParkAssistBaseType::enRVCError::RVC_NoVideo); 
                //Informing HMI that camera is switched off
                LOG_INFO(LOG_RVC,"RECEIVED RVC_SCREEN_Off From RVC service \n");
                ZoomIconOnOff(true);
                setRVCDisPlayStatusAttribute(ParkAssistBaseType::enRVCStatus::RVC_Off);
                if(NULL != m_pobjContext)
                {
                    m_pobjContext->m_bIsRVCOn = false;
                }
                CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
            }
            break;
        case RVC_NOT_CONFIGURED:
            {
                LOG_INFO(LOG_RVC,"RVC is not configured \n");
                //Inform HMI that RVC is not configured
                      
            }
                
        default:  LOG_INFO(LOG_RVC,"ProcessNanoMessage Default case ");
    }
}
                            
/**
@brief : To Handel RVC turn off logic in case of gear fault, camera delay on and off
@param : none
 */
void RVCServiceStubImpl::ProcessRVCOffRequest()
{   
    if(m_pobjContext->m_bContextIsRVCSupported)
    {
        unique_lock<mutex>lock(m_ExitTimerlockMutex);
        if(m_GearFault)
        {
            //Already handling the Gear fault usecase in NotifyGearStatus 
            LOG_INFO(LOG_RVC,"Gear fault is not recovered and Acknowledging ford video app to switch off \n");
            //Set the DTC and inform ford video app that gear fault is not recovered after 1000ms, turn off the RVC video
            SendNanoMessage(m_Socket,SWICTH_OFF_RVC_ACK);
        }
        //APA is ON
        else if((m_pobjContext->m_bIsAPAOn) && (!m_CameraMaxSpeed))
        {
            //Cancel the  camera delay on request if already requested
            if((m_timerInstance.m_bFlagExecute) && (m_pobjContext->m_bIsCameraDealyOn))
            {
                LOG_INFO(LOG_RVC,"APA is on and dont switch off the RVC");
                m_IsTimerRunning = true;
                m_WaitMaxSpeedCondVar.notify_one();
                m_timerInstance.stopTimer();
                m_IsTimerRunning = false;
            }
        }
        else if(m_pobjContext->m_bIsCameraDealyOn)
        {
            //Shown the camera for minimum 2 seconds 
            LOG_INFO(LOG_RVC,"camera Delay Setting is on ");

            //If already timer is initiated , stop the timer and start new timer with 2 seconds
            //Notifying condition variable MaxSpeed to  make sure that previous callback thread to be exited before starting new timer
            //Waiting on  condition variable PrevTimer to  make sure that previous callback thread exited properly
            
            m_IsTimerRunning = true;

            m_WaitMaxSpeedCondVar.notify_one();
             m_timerInstance.stopTimer();
            int l_intCameraExitValue = 2000 ;

            if(NULL != m_pobjContext)
            {
                l_intCameraExitValue = m_pobjContext->m_intCamra_Exit_Timr_CfgData;
            }
            LOG_INFO(LOG_RVC,"Staring Camera delay on timer");
            m_timerInstance.startTimer(std::chrono::milliseconds(l_intCameraExitValue), tCameraDelaycbk);


            //To indicate old timer killed properly and new timer callback therad can send switch off RVC if required condition are met
            m_IsTimerRunning = false;

        }
        else
        {
            LOG_INFO(LOG_RVC,"camera Delay is off  and Ack to switch of the camera");
            //Acknowledge ford video app to switch off the RVC display
            SendNanoMessage(m_Socket,SWICTH_OFF_RVC_ACK);
        }   
        lock.unlock();
    }   
}


/**
    @brief :Before turning of RVC display , Wait for vehicle speed crosses 10 kph
    @param  None
 */
void RVCServiceStubImpl::RVCOffRequestonCameradelay()
{
    //check the vehicle speed crosses 10KMPH and Target is not in standby state
    unique_lock<mutex>lock(m_SpeedlockMutex);
    LOG_INFO(LOG_RVC,"Vehicle speed :%d NSM State :%d Vehicle Parked:%d \n" ,m_CameraMaxSpeed,m_NsmSessionState,m_VehParked);
    LOG_INFO(LOG_RVC,"Ignition Status :%d APA gear Status:%d APA system access :%d \n" ,m_Ignitionoff,m_APAGearStatus,m_APASysAcess);
    if((!m_GearFault) && (!m_CameraMaxSpeed) && (!m_NsmSessionState) && (!m_VehParked) && (!m_Ignitionoff)&& (!m_CancelIconPresed) && (!((m_APAGearStatus) && (m_APASysAcess))))
    {
        /*When camera delay is On , Switch off the camera when one off the following condition are met
        1.Wait till Vehicle enter to PARK mode
        2.Wait till Power mode is stand by
        3.Wait till Vehicle speed crosses than 10KMPH
        4.Wait till Ignition status is OFF
        5.Wait till APA system is inaccessible
        6.Wait till cancel icon is pressed*/
        
        LOG_INFO(LOG_RVC,"Waiting for speed to cross 10km/hr to switch off the camera");
        m_WaitMaxSpeedCondVar.wait(lock);
    }
    LOG_INFO(LOG_RVC,"Switching off because off Vehicle speed  :%d NSM State :%d Vehicle Parked:%d" ,m_CameraMaxSpeed,m_NsmSessionState,m_VehParked);
    LOG_INFO(LOG_RVC,"Ignition Status :%d APA gear Status:%d APA system access%d" ,m_Ignitionoff,m_APAGearStatus,m_APASysAcess);

    
    //Checking m_IsTimerRunning to find whether notifying of speed cond variable is because of New timer or vehicle speed crosses 10k 
    if(!m_IsTimerRunning)
    {
        //There is no new request and processing the camera off request
        LOG_INFO(LOG_RVC,"Switching of the camera");

        //Inform ford video app to switch off the video 
        SendNanoMessage(m_Socket,SWICTH_OFF_RVC_ACK);

    }   
    LOG_INFO(LOG_RVC,"exiting callback");
    //Notifying timer has exited gracefully
    lock.unlock();

}

/**
    @brief :Update the camera speed 
    @param  None
 */
 
void RVCServiceStubImpl::UpdateCameraSpeedState(bool p_bCameraSpeed)
{
    //Updating variable to true if vehicle speed greater than 10km/hr
    LOG_INFO(LOG_RVC,"Update Camera SpeedState :%d",p_bCameraSpeed);
    unique_lock<mutex>lock(m_SpeedlockMutex);
    m_CameraMaxSpeed = p_bCameraSpeed;
    if(true == p_bCameraSpeed)
    {
        //Switching off the camera if vehicle speed more than 10KMPH
        if(m_pobjContext->m_bIsAPAOn)
        {
            //Handling APA case 
            RVCSwitchOffByAPA();
        }
        else
        {
            LOG_INFO(LOG_RVC,"Switching off RVC when vehicle speed more than 10km/ph");
            RVCSwitchOffCamera();
        }   
    } 
        

}



/**
    @brief Conversion from AMB related zoom value to HMI related value
    @param:uint16_t
 */
void RVCServiceStubImpl::ProcessZoomResponce(uint16_t CamraZoom)
{
    //To Do Implement ion

    LOG_INFO(LOG_RVC, "ProcessZoomResponce received in rvc stub...\n");
    switch (CamraZoom)
    {
        case camerainfo_types::CamraZoomMan_D_Actl_enum::En_Off:
             LOG_INFO(LOG_RVC,"Notification From AMB :: The Value of zoom is off ");
             //indicate HMI that zoom off request is completed from AMB , Update attribute only when it is zoom requested is made by HMI/PAM 
             if(ParkAssistBaseType::enRVCZoom::RVC_Zoom_Off_Request == getRVCZoomOnOffAttribute())
             {
                setRVCZoomOnOffAttribute(ParkAssistBaseType::enRVCZoom::RVC_Zoom_off_Completed);
             }  
             break;
        case camerainfo_types::CamraZoomMan_D_Actl_enum::En_Zoom_Level_III:
            LOG_INFO(LOG_RVC,"Notification From AMB ::  The Value of zoom is on ");
             //indicate HMI that zoom on request is completed from AMB , Update attribute only when it is zoom requested is made by HMI/PAM 
             if(ParkAssistBaseType::enRVCZoom::RVC_Zoom_On_Request == getRVCZoomOnOffAttribute())
             {
                setRVCZoomOnOffAttribute(ParkAssistBaseType::enRVCZoom::RVC_Zoom_on_Completed);
             }
             break;
        default:
             LOG_INFO(LOG_RVC,"Default ");
    }

}

void RVCServiceStubImpl::ProcessSplitViewResponce(uint16_t p_CameraSplitView)
{
    LOG_INFO(LOG_RVC, "ProcessSplitViewResponce received in rvc stub...\n");
    switch (p_CameraSplitView)
    {
        case camerainfo_types::CamraViewSplit_D_Actl_enum::En_Inactive:
            LOG_INFO(LOG_RVC,"HMI updating state to ::RVC_SplitView_off_Completed");
             //indicate HMI that zoom off request is completed from AMB , Update attribute only when it is zoom requested is made by HMI/PAM 
             setRVCSpiltViewOnOffAttribute(ParkAssistBaseType::enRVCSplitView::RVC_SplitView_off_Completed);
             break;
        case camerainfo_types::CamraViewSplit_D_Actl_enum::En_Active:
            LOG_INFO(LOG_RVC,"HMI updating state to ::RVC_SplitView_on_Completed");
            setRVCSpiltViewOnOffAttribute(ParkAssistBaseType::enRVCSplitView::RVC_SplitView_on_Completed);
            break;
        default:
             LOG_INFO(LOG_RVC,"Default ");
    }
//TO DO IMPLEMEMNT
}


/**
    @Brief:Updating Trunck status to HMI
    @param  enginedata_types::DrStatTgate_B_Actl_enum 
 */
void RVCServiceStubImpl::UpdateVehicelTrunkStatus(enginedata_types::DrStatTgate_B_Actl_enum p_eTrunkStatus)
{
    if(p_eTrunkStatus == enginedata_types::DrStatTgate_B_Actl_enum::En_Ajar)
    {
        //Informing HMI that trunk status is Ajar/liftgate . 
        setRVCTrunkStatusAttribute(true);
        LOG_INFO(LOG_RVC,"Trunk status is Ajar ");
    }
    else
    {
        //Informing HMI that trunk status is closed
        setRVCTrunkStatusAttribute(false);
        LOG_INFO(LOG_RVC,"Trunk status is closed ");
    }

}

/**
    @Brief:Receiving Manual Gear status from AMB
    @param  None
 */

void RVCServiceStubImpl::UpdateManualGearStatus(rearviewcamclient_types::GearRvrse_D_Actl_enum p_eManualGearStatus)
{
    if(rearviewcamclient_types::GearRvrse_D_Actl_enum::En_Active_confirmed == p_eManualGearStatus)
    {
        //For manual transmission , Reverse gear will be active when GearRvrse_D_Actl_enum value is ACTIVE_CONFIRMED and  ACTIVE_NOT_CONFIRMED
        m_ManualGear = ACTIVE;
        LOG_INFO(LOG_RVC,"Vehicle is reverse mode in Manual Transmission ");
    }
    else if((rearviewcamclient_types::GearRvrse_D_Actl_enum::En_Inactive_confirmed == p_eManualGearStatus) || (rearviewcamclient_types::GearRvrse_D_Actl_enum::En_Inactive_not_confirmed == p_eManualGearStatus) || (rearviewcamclient_types::GearRvrse_D_Actl_enum::En_Active_not_confirmed == p_eManualGearStatus))
    {
        //For manual transmission , Reverse gear will be inactive when GearRvrse_D_Actl_enum value is En_Inactive_confirmed and  En_Inactive_not_confirmed
        m_ManualGear = INACTIVE;
        LOG_INFO(LOG_RVC,"Vehicle is Forward mode in Manual Transmission ");
    }
    else if(rearviewcamclient_types::GearRvrse_D_Actl_enum::En_Fault)
    {
        //Gear fault for Manual Transmission
        //Commenting Untill AMB fixes the default case issue
    //    m_ManualGear = FAULT;
        LOG_INFO(LOG_RVC,"Gear Fault Happened in Manual Transmission ");
    }
    //Determining whether vehicle enter into Parking mode
    CalculateGearStatus();
}
/**
    @Brief:Setting Default values once AMB is Avaliabel
    @param  None
 */
void RVCServiceStubImpl::SetCameraInfoDefaultSettings()
{
     LOG_INFO(LOG_RVC,"SetCameraInfoDefaultSettings called from Manager ");
    if(m_pobjContext->m_bContextIsRVCSupported)
    {
        LOG_INFO(LOG_RVC,"SetCameraInfoDefaultSettings call ");
        //Setting default camera setting zoom , dynamic guidelines and enhance mode once AMB Proxy Avaliabel
        EParkAssistReqId l_eReqId = e_ParkAssist_RVC_GUIDELINES_REQUEST;
        CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
        l_eReqId = e_ParkAssist_RVC_ZOOM_REQUEST;
        CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
        l_eReqId = e_ParkAssist_RVC_SPLITVIEW_REQUEST;
        CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
        l_eReqId = e_ParkAssist_RVC_ENHANCEDMODE_REQUEST;
        CPresCoreHandler::getInstance()->addRequestToPresCore(l_eReqId);
    }

}



/**
    @Brief:Notification from NSM related to current state of NSM is active or no
    @param  None
 */
void RVCServiceStubImpl::UpdateNSMState(bool p_bNsmSessionState)
{
    //Updating NSM state is active or inactive
    LOG_INFO(LOG_RVC,"UpdateNSMState");
    m_NsmSessionState = p_bNsmSessionState;
    //Switch of the camera If NSM session state in inactive and if PAM is waiting to switch of the camera depending on camera speed to cross 10km/hr ,
    if(true == m_NsmSessionState)
    {
        LOG_INFO(LOG_RVC,"Switching off the camera because ignition is not equal to run");
        //Switch off the camera if session state is inactive
        RVCSwitchOffCamera();
    }

}

/** 
    @Brief : Notification related to Ignition of Vehicle 
**/
void RVCServiceStubImpl::UpdateIgnitionState(bool IgnitionValue)
{
    //Updating NSM state is active or inactive
    LOG_INFO(LOG_RVC,"UpdateNSMState");
    m_Ignitionoff = IgnitionValue;
    //Switch of the camera if ignition status not equal to run and start
    if(true == m_Ignitionoff)
    {
        LOG_INFO(LOG_RVC,"Switching off the camera because ignition is not equal to run");
        //Switch off the camera if session state is inactive
        RVCSwitchOffCamera();
    }
}   
 
 /* @Brief:Calculating Manual Gear Status
    @param  None
 */
void RVCServiceStubImpl::CalculateGearStatus()
{
    LOG_INFO(LOG_RVC,"CalculateGearStatus");
    m_VehParked = false;
    m_GearFault = false;
    if(ACTIVE == m_ManualGear)
    {
        //Vehicle in reverse gear in manual transmission
        m_ReverseGearStatus = true;
        LOG_INFO(LOG_RVC,"Vehicle is reverse gear");
    }
    else if((INACTIVE == m_ManualGear) && (true == m_ParkBrakeStatus))
    {
        //Vehicle in Park mode and switch off the camera display if camera delay is on
        m_VehParked = true;
        m_ReverseGearStatus = false;
        LOG_INFO(LOG_RVC,"Switching Camera because vehicle in Parked mode in manual transmission");
        RVCSwitchOffCamera();
    }
    else if((INACTIVE == m_ManualGear) && (false ==m_ParkBrakeStatus))
    {
        //Vehicle in Non reverse mode other than PARK and don't switch off the camera if camera delay is on
        m_ReverseGearStatus = false;
        LOG_INFO(LOG_RVC,"Vehicle in not in Reverse park mode  in  Manual transmission");
    }
    else if(FAULT == m_ManualGear)
    {
        //Gear fault is happened for manual transmission
        LOG_INFO(LOG_RVC,"Fault happened in Manual Transmission");
        m_GearFault = true;
    }
    //notifying gear status of vehicle
    NotifyGearStatus();

}

/**
    @Brief:Calculating APA system status is NOT_ACCESSIBLE or not
    @param  None
 */
void RVCServiceStubImpl::UpdateAPASystemStatus(actvparkassist_types::ApaSys_D_Stat_enum p_ApaSysStatus)
{
    if(actvparkassist_types::ApaSys_D_Stat_enum::En_NotAccessible == p_ApaSysStatus)
    {
        //system's operational state is Not accessible
        LOG_INFO(LOG_RVC,"system's operational state is Not accessible");
        m_APASysAcess = true;
    }
    else
    {
        //system's operational state is  accessible
        LOG_INFO(LOG_RVC,"system's operational state is accessible");
        m_APASysAcess = false;
    }
    ProcessAPAGearStatus();

}

/**
    @Brief:Calculating APA Gear status is SHIFT_TO_D or not
    @param  ApaGearShif_D_RqDrv_enum
*/
void RVCServiceStubImpl::UpdateAPAGearStatus(actvparkassist_types::ApaGearShif_D_RqDrv_enum p_eApaGearStatus)
{
    if(actvparkassist_types::ApaGearShif_D_RqDrv_enum::En_ShiftToD == p_eApaGearStatus)
    {
        //APA Gear Shift Input is SHIFT_TO_D
        LOG_INFO(LOG_RVC,"APA Gear Shift Input is SHIFT_TO_D");
        m_APAGearStatus = true;
    }
    else
    {
        LOG_INFO(LOG_RVC,"APA Gear Shift Input is other than SHIFT_TO_D");
        m_APAGearStatus = false;
    }
    //Determining whether to switch off the camera based on APA accessibility
    ProcessAPAGearStatus();
}

/**
    @Brief:Calculating Manual Gear Status depending on APA system status and APA gear status 
    @param  None
 */
void RVCServiceStubImpl::ProcessAPAGearStatus()
{
    //If camera delay is on , If is not in reverse mode, Switch off the camera if APA Gear Shift is SHIFT_TO_D and system's operational state is Not accessible
    if((true == m_APAGearStatus) && (true == m_APASysAcess))
    {
        LOG_INFO(LOG_RVC,"Deactive RVC for APA signals ");
        //Switch off the camera 
        RVCSwitchOffCamera();
    }

}

/**
    @brief Check for RVC switch off because off Gear Fault
    @param : None
    */
void RVCServiceStubImpl::WaitForAMBUpdate()
{
    LOG_INFO(LOG_RVC,"Waiting for Switch off reason from AMB ");
    unique_lock<mutex>lock(m_RVCStopLockMutex);
    //Wait until to know the gear status from AMB or 500 mill second 
    m_WaitForRVCStopReason.wait_for(lock, std::chrono::milliseconds(1000));
    LOG_INFO(LOG_RVC,"Found out the reason for RVC switch off");
}
 /*   @Brief:Switching off the camera for camera on feature
    @param  None
 */
void RVCServiceStubImpl::RVCSwitchOffCamera()
{
    //if Camera delay is on functionality enabled
    if( true == getCameraDelayOnOffAttribute())
    {
        LOG_INFO(LOG_RVC,"Camera delay is on ");
        //if RVC display rendering on screen
        if( ParkAssistBaseType::enRVCStatus::RVC_On == getRVCDisPlayStatusAttribute())
        {
            m_WaitMaxSpeedCondVar.notify_one(); //Switch off the RVC screen
            LOG_INFO(LOG_RVC,"Switching off the RVC display");
        }
    }   
}

/**
    @brief Clean-up before destroying the component
    @param : None
*/
void RVCServiceStubImpl::Deinitilize()
{
    //Sending dummy message to unblock the message queue in-case if it's empty
    m_ThreadExit = true;
    //Wait till Nano message Thread returns
    m_NanoMsgThread.join(); 
}

/**
    @Brief:Notifying reverse gear position From AMB
    @param  None
 */
void RVCServiceStubImpl::NotifyGearStatus()
{
    if( ParkAssistBaseType::enRVCStatus::RVC_On == getRVCDisPlayStatusAttribute())
    {
        //If RVC is on , notify reason to  switch off the camera display is because of fault or not
        m_WaitForRVCStopReason.notify_one();
        if(m_GearFault)
        {
            LOG_INFO(LOG_RVC, "RVCServiceStubImpl::NotifyGearStatus() -> RVCSwitchOffCamera() Called");
            RVCSwitchOffCamera();
        }
        LOG_INFO(LOG_RVC,"NotifyGearStatus : Notifying gear position signal from AMB and check for Gear fault ");

        //If camera delay option is on , if vehicle in reverse gear then show zoom icon or else show cancel icon
        if(m_pobjContext->m_bIsCameraDealyOn)
        {
            if(m_ReverseGearStatus)
            {
                //Inform HMI to show Zoom Icon
                LOG_INFO(LOG_RVC,"Showing Zoom icon");
                ZoomIconOnOff(true);
            }
            else
            {
                //Inform HMI to Show cancel icon
                LOG_INFO(LOG_RVC,"Showing cancel icon");
                ZoomIconOnOff(false);
            }
        }
        LOG_INFO(LOG_RVC,"NotifyGearStatus :Gear status is other than fault");
        
    }

}

//Show the zoom icon when Value is true
//Show the cancel icon when value is false
void RVCServiceStubImpl::ZoomIconOnOff(bool l_value)
{
 //Check RVC display and camera delay option is on 
    if( ParkAssistBaseType::enRVCStatus::RVC_On == getRVCDisPlayStatusAttribute())
    {
        if(m_pobjContext->m_bIsCameraDealyOn == true)
        {
            if(true == l_value)
            {
                LOG_INFO(LOG_RVC,"Indicating HMI to show  Zoom Icon");
                //Inform HMI to show zoom icon
                //Reset the cancel icon to false
                setDisplayIconTypeAttribute(ParkAssistBaseType::enDisplayIconType::e_ZOOM_ICON);
                m_CancelIconPresed = false;
            }
            else
            {
                LOG_INFO(LOG_RVC,"Indicating HMI to show  Cancel Icon");
                setDisplayIconTypeAttribute(ParkAssistBaseType::enDisplayIconType::e_RVC_CANCEL_ICON);
            }
        }   
    }
}

void RVCServiceStubImpl::RVCSwitchOffByAPA()
{
    LOG_INFO(LOG_RVC,"RVCSwitchOffByAPA is called");
    if( ParkAssistBaseType::enRVCStatus::RVC_On == getRVCDisPlayStatusAttribute())
    {
        //Sending Ford video App to switch off RVC
         ProcessRVCOffRequest();
    
    }


}

void RVCServiceStubImpl::CancelRVCReq(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::ParkAssist::ParkAssistBaseType::enCancelRVC _m_eCancelRVC, CancelRVCReqReply_t _reply)
{
    LOG_INFO(LOG_RVC,"Cancel Request From HMI");
    m_CancelIconPresed = true;
    m_WaitMaxSpeedCondVar.notify_one();
}


} // namespace RVC
} // namespace harman
} // namespace com
} // namespace v0

