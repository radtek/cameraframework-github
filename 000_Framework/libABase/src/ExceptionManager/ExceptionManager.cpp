//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : ExcpectionManager.cpp
//  @ Date : 2017/3/8 ÐÇÆÚÈý
//  @ Author : 
//
//

#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "ExcpectionManager.h"
#include "RVSService.h"

ExcpectionManager * ExcpectionManager::m_pInstance = NULL;
ExcpectionManager::ExcpectionManager()
: m_bQuit(false)
, m_bCamState(false)
, m_bCamSyncState(false)
, m_iCamThreadCnt(0)
, m_pScreenBuf(NULL)
, m_LastCRC(0)
{
	;
}

ExcpectionManager::~ExcpectionManager()
{
	if (m_pScreenBuf) delete[] m_pScreenBuf;
}

void* run_ExcpectionManager(void* arg)
{
	return ExcpectionManager::getInstance()->run(arg);
}
void ExcpectionManager::start()
{
	//Thread for Message queue
	m_ScreenShot.iInit();
	//m_ScreenShot.iDumptoBMP("aaaaaaa.bmp",m_pScreenBuf);
	//printf("ExcpectionManager: display test aaaaaaaaaa!\n");
	pthread_create(&m_hThread, NULL, &run_ExcpectionManager, NULL);

}

static unsigned int s_cnt = 0;
static int s_LastCamThreadCnt=0;
#define CRC_DISPLAY_HEIGHT 45

TRC_SCOPE_DEF(RVC, ExcpectionManager, run);
void* ExcpectionManager::run(void*)
{
    int iCRCLen = m_ScreenShot.iGetScreenWidth()* CRC_DISPLAY_HEIGHT*4;
    int iBufSize = m_ScreenShot.iGetScreenWidth()*  m_ScreenShot.iGetScreenHeight()*4;
    uint32_t s_CurrentCRC = 0xFFFFFFFF;
	m_pScreenBuf = new char[iBufSize];
	if(!m_pScreenBuf)
	{
		printf("alloc mem falied for screen shot ,exit ExcpectionManager \n");
		return NULL;
	}
	while (!m_bQuit)
	{

		//printf("ExcpectionManager::run() %d\n", s_cnt);
		usleep(2000000);
		if((m_bCamState)&&(m_bCamSyncState))
		//if(true)
		{
			TRC_SCOPE(RVC, ExcpectionManager, run);
			//test
			char tname[100];
			m_ScreenShot.iDumptoBuffer(m_pScreenBuf);
			s_CurrentCRC = rc_crc32(0, (const char *)m_pScreenBuf, iCRCLen);
			if(m_LastCRC==s_CurrentCRC)
			{
				s_cnt++;
				sprintf(tname, "/harman/testdump%d.bmp",s_cnt%20);
				if(m_bCamState) RVSService_emit_FailSafeMsg(eDISPLAY_FREEZE);
				DBG_MSG(("ExcpectionManager: display freeze and dump ! ---> %s\n",tname));
				m_ScreenShot.iDumptoBMP(tname,m_pScreenBuf);
				vCreateFileTagFreeze();
			}

			if(s_LastCamThreadCnt==m_iCamThreadCnt)
			{
				if(m_bCamState) RVSService_emit_FailSafeMsg(eCAMBUFF_SWAP_BLK);
				DBG_MSG(("ExcpectionManager: display swap block !\n"));
			}
			if((m_LastCRC!=s_CurrentCRC)
			&&(s_LastCamThreadCnt!=m_iCamThreadCnt))
			{
				if(m_bCamState) RVSService_emit_FailSafeMsg(eNO_EXCEPETION);
				DBG_MSG(("ExcpectionManager: display good !\n"));
			}
			m_LastCRC = s_CurrentCRC;
			s_LastCamThreadCnt = m_iCamThreadCnt;
		}
		else
		{
			m_LastCRC = 0;
			m_bCamSyncState =false;
		}

	}
	return NULL;
}

ExcpectionManager* ExcpectionManager::getInstance()
{
	if (m_pInstance == NULL)
	{
		m_pInstance = new ExcpectionManager();
	}
	return m_pInstance;
}

void ExcpectionManager::delInstance()
{
	if (m_pInstance != NULL)
	{
		delete m_pInstance;
		m_pInstance = NULL;
	}
}
#define RVS_FAIL_SAFE_FLAG "/harman/rvs/RVS_FAIL_SAFE_POPUP_%s"
#define RVS_FAIL_SAFE_FOLDER_FLAG "/harman/rvs"

void ExcpectionManager::vCreateFileTagFreeze()
{
  if (access(RVS_FAIL_SAFE_FOLDER_FLAG, 0) == -1)
  {
	  mkdir(RVS_FAIL_SAFE_FOLDER_FLAG,S_ISGID);
  }
  //else
  {
	FILE *fp = NULL;

	char            fmt[64], tmp[256];
	struct timeval  tv;
	struct tm       *tm;

	gettimeofday(&tv, NULL);
	tm = localtime(&tv.tv_sec);
	strftime(fmt, sizeof fmt, "%Y%m%d", tm);

	//printf ( "Current local time and date: %s\n", fmt );
	sprintf (tmp, RVS_FAIL_SAFE_FLAG, fmt);

	//printf("location: %s\n", tmp);

	fp=fopen(tmp,"w+");
	if(fp != NULL)
	{
		  fclose(fp);
	}
  }
}

void ExcpectionManager::vSetCameraState(bool bCamState)
{
	m_LastCRC=(m_bCamState!=bCamState)?0:m_LastCRC;
	m_bCamState = bCamState;
	m_bCamSyncState = false;
};
